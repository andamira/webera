#!/usr/bin/env bash
#
# webera tests helper
#
# dependencies: grep, sed, awk, wget, coreutils
#


helper_main() {

	# Initializations
	helper_init_common

	[[ "$NOT_SOURCED" ]] && helper_arguments "$@"

} # helper_main()


# shellcheck disable=SC1090
helper_init_common() {

	__check_compatibility

	DIR_TESTS="$( cd -- "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
	DIR_WEBERA="$DIR_TESTS/.."

	TEMPLATE_TEMP_NAME='webera-test-XXXXXXXXX'

	# Exports
	if [[ ! -d $DIR_WORKDIR ]]; then
		# if possible, use a previously created workdir
		# if not, create a new one and export it again
		export DIR_WORKDIR
		DIR_WORKDIR="$(mktemp -d "$MKTEMP_ARGS" "$TEMPLATE_TEMP_NAME")"
	fi
	if [[ -z "$TOTAL_TEST_NUM" ]]; then
		export TOTAL_TEST_NUM
		TOTAL_TEST_NUM="$(mktemp "$MKTEMP_ARGS" "$TEMPLATE_TEMP_NAME")"
		printf '0' > "$TOTAL_TEST_NUM"
	fi
	if [[ -z "$TOTAL_TEST_TIME" ]]; then
		export TOTAL_TEST_TIME
		TOTAL_TEST_TIME="$(mktemp "$MKTEMP_ARGS" "$TEMPLATE_TEMP_NAME")"
		printf '0' > "$TOTAL_TEST_TIME"
	fi
	if [[ -z "$TOTAL_TEST_ERROR_NUM" ]]; then
		export TOTAL_TEST_ERROR_NUM
		TOTAL_TEST_ERROR_NUM="$(mktemp "$MKTEMP_ARGS" "$TEMPLATE_TEMP_NAME")"
		printf '0' > "$TOTAL_TEST_ERROR_NUM"
	fi

	# Imports
	[[ -f "$DIR_TESTS/aserta" ]] || helper_install_dependency aserta
	source "$DIR_TESTS/aserta" -v
	source "$DIR_WEBERA/webera"

	# set up exit traps
	trap helper_cleanup_signal SIGHUP SIGINT SIGTERM
	trap helper_cleanup_exit EXIT

} # helper_init_common()


helper_usage() {
	cat -- <<- ENDUSAGE

	Runs all the tests
	Also this file must be imported by each test file.

	Usage: ./helper [option]

	  -a, --run-all              run all the tests.

	  -i, --install=<DEP>        download and install a supported dependency:
	                             aserta, ...

	  -h, --help                 display this help and exit.
	ENDUSAGE
	exit

} # helper_usage()


helper_arguments() {

	[[ -z "$@" ]] && helper_usage

	local OPTIND option

	while getopts ':ahi:-:' option; do

		case "$option" in

			# long options
			-)
				case "$OPTARG" in

					run-all) helper_run_all_tests ;;
					help) helper_usage ;;

					install=*)
						helper_install_dependency "${OPTARG#*=}"
						;;
				esac ;;

			# short options
			a) helper_run_all_tests ;;
			i) helper_install_dependency "$OPTARG" ;;

			h) helper_usage ;;
			*)
				printf 'Error: "%s" is not a valid argument' "$option" >&2
				exit 1
		esac
	done

} # helper_parseArguments()


helper_run_all_tests() {

	# First check the compatibility
	__checkCompatibility

	# Manual ordered list of test files
	local testFiles=()

	testFiles+=('test-helper')
	testFiles+=('test-arguments')
	testFiles+=('test-config')
	#testFiles+=('test-log')
	#testFiles+=('test-templates')
	#testFiles+=('test-resources')

	printf '%s\n' "Running tests from ${#testFiles[@]} test files. . ."

	for T in "${testFiles[@]}"; do
		bash "$DIR_TESTS/$T"
	done

	test_final_summary

	[[ "$TESTS_FAILED" -eq 0 ]]

} # helper_run_all_tests()



# PRESENTATION
# ############


test_separator() {
	printf '%s' '-----------------------------'
}



test_h1() {
	if [[ "$DEBUG" -gt 0 ]]; then
		printf '\n\n[Testing %s]\n' "$@"
	fi
}



test_h2() {
	if [[ "$DEBUG" -gt 0 ]]; then
		printf '\n  + %s:' "$@"
	fi
}



test_h3() {
	if [[ "$DEBUG" -gt 0 ]]; then
		printf '\n    - %s:' "$@"
	fi
}



# SETUP
# #####


# enters the working directory
test_setup() {
	if [[ -d "$DIR_WORKDIR" ]]; then
		pushd "$DIR_WORKDIR" >/dev/null 2>&1
	else
		printf 'Warning: %s %s.' \
			"couldn't find working directory" \
			"'$DIR_WORKDIR'" >&2

		export DIR_WORKDIR
		DIR_WORKDIR="$(mktemp -d "$MKTEMP_ARGS" "$TEMPLATE_TEMP_NAME")"

		printf 'Warning: %s %s.' \
			"creating a new working directory at" \
			"'$DIR_WORKDIR'" >&2

		pushd "$DIR_WORKDIR"
	fi

} # test_setup()


# returns from and deletes the working directory
test_teardown() {
	if [[ "$(pwd)" == "$DIR_WORKDIR" ]]; then
		popd >/dev/null 2>&1
	fi

	if [[ -d "$DIR_WORKDIR" ]]; then
		test_clean
	   	rmdir -- "$DIR_WORKDIR"
	fi

} # test_teardown()


# cleans the working directory
test_clean() {
	if [[ -d "$DIR_WORKDIR" ]]; then
		pushd "$DIR_WORKDIR" >/dev/null 2>&1
		rm -rf -- .[^.] .??* ./*
		popd >/dev/null 2>&1
	else
		printf '%s\n' \
			"Warning: couldn't find working directory '$DIR_WORKDIR'" >&2
	fi

} # test_clean()



# REPORT
# ######


# prints the report and saves the counts for the final summary
test_summary() {
	local testStr="$1"

	local testReport
	local testNum
	local previousTotalNum
	local newTotalNum

	local errorReport
	local whatFailed
	local testErrNum
	local previousTotalErrNum
	local newTotalErrNum

	local testTime
	local previousTotalTime
	local newTotalTime

	local errPattern='[0-9]\+ of [0-9]\+ .* tests failed.*$'

	testReport="$(assert_end \'"$testStr"\' | tr -d '\n' )"

	printf '\n  %s' "$(test_separator)"

	# No tests failed
	if [[ "$(printf '%s' "$testReport" | cut -d' ' -f1)" == "all" ]]; then
		printf '\n  %s\n' "$testReport"

		# get the number of passed tests
		testNum="$(printf '%s' "$testReport" \
			| grep -o '^all [0-9]\+' | cut -d' ' -f2 )"

	# Some tests failed
	else
		whatFailed="$(printf "%s" "$testReport" | sed "s/\($errPattern\)//" )"
		errorReport="$(printf "%s" "$testReport" | grep -o "$errPattern" )"

		printf '%s\n' "$whatFailed" | tr '\t' '\n' \
			| sed 's/\(test\ #[0-9]\)/\n> &/g' | sed 's/^/  /'
		printf '  %s\n' "$(test_separator)"
		printf '  %s\n' "$errorReport"

		# Update the number of failed tests
		if [[ -f "$TOTAL_TEST_ERROR_NUM" ]]; then
			testErrNum="$(printf '%s' "$errorReport" | cut -d' ' -f1 )"
			previousTotalErrNum="$(cat -- "$TOTAL_TEST_ERROR_NUM")"
			newTotalErrNum="$(awk \
				"BEGIN {print $testErrNum+$previousTotalErrNum; exit}")"

			printf '%s' "$newTotalErrNum" > "$TOTAL_TEST_ERROR_NUM"
			TESTS_FAILED="$newTotalErrNum"
		fi

		# get the number of passed tests
		testNum="$(printf '%s' "$errorReport" | cut -d' ' -f3 )"
	fi

	# Update the number of passed tests
	if [[ -f "$TOTAL_TEST_NUM" ]]; then
		previousTotalNum="$(cat -- "$TOTAL_TEST_NUM")"
		newTotalNum="$(awk \
			"BEGIN {print $testNum+$previousTotalNum; exit}")"

		printf '%s' "$newTotalNum" > "$TOTAL_TEST_NUM"
	fi

	# Total time spent
	if [[ -z "$INVARIANT"  && -f "$TOTAL_TEST_TIME" ]]; then
		testTime="$(printf '%s' "$testReport" | grep -o '[0-9]\+.[0-9]\+s.' | cut -d's' -f1 )"
		previousTotalTime="$(cat -- "$TOTAL_TEST_TIME")"
		newTotalTime="$(awk "BEGIN {print $testTime+$previousTotalTime; exit}")"
		printf '%s' "$newTotalTime" > "$TOTAL_TEST_TIME"
	fi

	[[ "$TESTS_FAILED" -eq 0 ]]

} # test_summary()


test_final_summary() {
	local -i testTotal
	local -i testFailed

	testTotal="$(cat -- "$TOTAL_TEST_NUM")"
	testFailed="$(cat -- "$TOTAL_TEST_ERROR_NUM")"
	local -i testPassed="$((testTotal-testFailed))"

	printf '\n\n%s\n%s\n' "SUMMARY:" "$(test_separator)"
	printf '%s %16u\n' "Tests done:" "$testTotal"

	printf '%s %16u\n' "Tests pass:" "$testPassed"
	printf '%s %16u\n' "Tests fail:" "$testFailed"

	if [[ -z "$INVARIANT" ]]; then
		LC_NUMERIC=C LC_COLLATE=C
		printf '%s %16.2fs\n' "Time spent:" "$(cat -- "$TOTAL_TEST_TIME")"
	fi

	printf '%s\n' "$(test_separator)"

	test_final_cleanup

} # test_final_summary()


test_final_cleanup() {
	[[ -f "$TOTAL_TEST_NUM" ]] && rm -f -- "$TOTAL_TEST_NUM"
	[[ -f "$TOTAL_TEST_TIME" ]] && rm -f -- "$TOTAL_TEST_TIME"

	if [[ -f "$TOTAL_TEST_ERROR_NUM" ]]; then
		TESTS_FAILED="$(cat -- "$TOTAL_TEST_ERROR_NUM")"
		rm -f -- "$TOTAL_TEST_ERROR_NUM"
	fi

	test_teardown

} # test_final_cleanup()


# This function gets called on test error
helper_cleanup_exit() {
	test_teardown
}


# This function gets called on abrupt exit
helper_cleanup_signal() {
	test_final_cleanup
}



# WEBERA
# ######


# Binary wrapper
webera() { "$DIR_WEBERA/webera" "$@" 2>/dev/null; }


# Parse a list of variables in debug info format
# and return the corresponding value.
#
#  [$varType]::$varName=$varValue
#
weberaVarValue() {
	local webera_vars="$1"
	local varType="$2"
	local varName="$3"

	shopt -s extglob
	local varTypesAllowed='@(vdef|file|args|strn)'

	case "$varType" in
		$varTypesAllowed) ;;
		*) printf '%s' "ERROR: Unknown var type '$varType'." 1>&2 ;;
	esac
	shopt -u extglob

	printf '%s' "$webera_vars" \
		| grep "^\[$varType\]:.*:$varName=" \
		| cut -d':' -f3 \
		| cut -d'=' -f2

} # weberaVarValue()


# downloads and installs a dependency
#
helper_install_dependency() {
	declare dependency="$1"

	printf 'Installing dependency: %s . . .\n' "$dependency"

	case $dependency in
		aserta)
			#wget --quiet "https://github.com/andamira/aserta/releases/download/v2.1.1/aserta" \
			wget --quiet "git.io/aserta" \
				-O "$DIR_TESTS/aserta" && chmod +x "$DIR_TESTS/aserta"
			;;

		*) printf "Error: Can't recognize dependency '%s'." "$dependency" >&2
			exit 1 ;;

	esac
} # helper_install_dependency()


__check_compatibility() {

	# mktemp
	if [[ "$(mktemp -qu --tmpdir TXXX >/dev/null 2>&1; printf '%s' "$?")" -eq 0 ]]; then
		MKTEMP_ARGS="--tmpdir" # new syntax
	else
		MKTEMP_ARGS="-t" # obsolete syntax
	fi

} # __check_compatibility()


[[ "$0" == "${BASH_SOURCE[0]}" ]] && NOT_SOURCED=true

helper_main "$@"
