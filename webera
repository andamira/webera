#!/usr/bin/env bash
# shellcheck disable=SC2016
#
#         name : webera
#  description : a handy static website generator
#   repository : https://github.com/andamira/webera
#       author : José Luis Cruz © 2016-2017
#      license : MIT
_WEBERA_VERSION=0.1.68


#-------------------------------------------------------------------------------
# ::main
#
# > $@ : all the arguments passed to the script
#
webera::main() {


	## PRE-SETUP

	webera::check-compatibility

	local -ir __Time_stamp="$($__DATE '+%s%3N')" # [INC02]

	webera::setup-debugging

	# prepare to save a list of the default settings
	local __Vars_webera __Vars_before __Vars_after
	__Vars_before=$(set -o posix ; set | $__AWK -F= '{print $1"="}' )


	## CONFIGURABLE GLOBAL OPTIONS

	# 1. Variables prefixed with Opt_ are the configurable options.
	# 2. Variables starting with an underscore can't be configured from
	#    a file|string, but they can be set using script flag arguments.
	# 3. Variables that don't have an argument associated they can only
	#    can only be changed via config file|string.
	# 4. They are referenced from the config file by removing the Opt_
	#    prefix and without case sensitivity.

	# statuses
	local    _Opt_operational=false              # -trawn
	local    _Opt_do_process_templates=false     # -ta
	local    _Opt_do_process_templates=false     # -ta
	local    _Opt_do_process_resources=false     # -ra
	local    _Opt_do_preview_in_browser=false    # -w
	local    _Opt_do_generate_config_file=false  # -n

	# paths
	local     Opt_dir_templates=tem              # -T
	local     Opt_dir_resources=res              # -R
	local     Opt_dir_output=out                 # -O
	local     Opt_dir_build=build                # -B
	local    _Opt_config_file=.weberarc          # -F
	local    _Opt_config_string=""               # -S

	# delete output & build directories
	local    _Opt_do_delete_dir_output=true      # -d
	local     Opt_do_delete_dir_build=true

	# log
	local     Opt_log_file=log.txt               # -G
	local    _Opt_do_clear_log=false             # -c
	local -i  Opt_log_level=0                    # -L [0-3]

	# web browser
	local     Opt_web_browser="firefox"          # -W
	local     Opt_server_type="python"           # -S
	local     Opt_server_host="localhost"        # -H
	local -i  Opt_server_port=8192               # -P
	local     Opt_server_start=""
	local     Opt_server_stop=""

	# misc
	local    _Opt_do_display_usage=false         # -h
	local    _Opt_do_print_vars=false            # -_
	local -i  Opt_nesting_max=8


	## POST-SETUP

	# save the list of the default options
	__Vars_after="$(set -o posix ; set | $__SED '/^'\''/d' )"
	webera::debug-save-default-vars "$__Vars_before" "$__Vars_after" __Vars_webera


	## NON-CONFIGURABLE GLOBAL DATA

	# arrays
	declare -A _Options_args_array     # the options received as script arguments
	declare -A _Defined_cmd_map

	local -i _Nesting_level=0

	local _Config_whole    # where to save all the configuration
	local _Log_presaved    # where log is saved before there's a logfile

	local -r _Date_start="$($__DATE '+%Y-%m-%d %H:%M:%S' \
		-d @"${__Time_stamp:0:10}")" # [INC03]


	## STRING CONSTANTS

	# whitespace indentation and headline
	local -r __In="  " __In2="    " __In3="      "
	local -r __Hl='------------------------------------------------------'

	# reusable regexp patterns
	local -r __Ws="[[:space:]]" # whitespace
	local -r __Sed_trim_ws="s/^$__Ws*//;s/$__Ws*$//"
	local -r __Sed_del_comments="/^$__Ws*#.*/d" # starting in #
	local -r __Sed_del_empty_lines="/^$__Ws*$/d"
	local -r __Sed_join_split_lines=':x; /\\$/ {N; s/\\\n//; tx}' # ending in \


	## webera::main LOGIC

	webera::log "\n===============[$_Date_start]==============@\n" # s/@$/Opt_log_level/

	webera::parse-arguments "$@"

	# read the configuration files & string
	[[ "$_Opt_config_file" != "/etc/weberarc" ]] && webera::read-config file "/etc/weberarc"
	[[ "$_Opt_config_file" != "$HOME/.weberarc" ]] && webera::read-config file "$HOME/.weberarc"
	webera::read-config file "$_Opt_config_file"
	webera::read-config string '_Opt_config_string'

	webera::configure-options

	if [[ "$_Opt_do_print_vars" == true ]]; then
		webera::debug-print-vars; exit 0
	elif [[ "$_Opt_do_display_usage" == true || "$_Opt_operational" == false ]]; then
		webera::display-usage
	fi

	webera::setup-log

	[[ "$_Opt_operational" == false ]] && exit 1

	webera::delete-directories

	webera::read-config-commands

	[[ "$_Opt_do_process_resources" == true ]] && webera::process-resources
	[[ "$_Opt_do_process_templates" == true ]] && webera::process-templates

	webera::log "Total elapsed time: $(webera::elapsed-time true)"

	[[ "$_Opt_do_preview_in_browser" == true ]] && webera::preview-website
	exit 0

} # ::main


#-------------------------------------------------------------------------------
# ::display-usage
#
#   Displays usage information.
#
# ^ ::parse-arguments ::configure-options
#
webera::display-usage() {

	cat -- <<-ENDUSAGE
Usage: $(basename "$0") -[trawn] [other options]

> a handy static website generator <

INSTRUCTIONS

1. At least one OPERATIVE FLAG is needed in order for the script to run.
2. Mandatory arguments to long options, are mandatory for short options too.

OPERATIVE FLAGS              ...

  -t, --process-templates    process the templates
  -r, --process-resources    process the resources
  -a, --process-all          process both the templates and the resources
  -w  --preview              preview website in the web browser
  -n  --new-config           generate a new configuration file

OPTION FLAGS                 ... (default value)

  -F, --file-config=FILE     indicate the configuration file ($_Opt_config_file)
  -C, --config=STRING        pass the configuration as a string ($_Opt_config_string)

  -T, --dir-templates=DIR    indicate the templates directory ($Opt_dir_templates)
  -R, --dir-resources=DIR    indicate the resources directory ($Opt_dir_resources)
  -O, --dir-output=DIR       indicate the output directory ($Opt_dir_output)
  -B, --dir-build=DIR        indicate the build directory ($Opt_dir_build)
  -d, --dont-delete-output   don't delete the output dir ($_Opt_do_delete_dir_output)

  -L, --log-level=LEVEL      log level [0=none|1|2|3] ($Opt_log_level)
  -c, --clear-log            clear the previous log file ($_Opt_do_clear_log)
  -G, --logfile=FILE         log file ($Opt_log_file)

  -W, --browser-bin=BIN      web browser binary ($Opt_web_browser)
  -S, --server-type=TYPE     server type [none|php|python|custom] ($Opt_server_type)
  -H, --server-host=HOST     server host ($Opt_server_host)
  -P, --server-port=PORT     port number ($Opt_server_port)

  -h, --help                 display this help and exit
      --version              show version info and exit

	ENDUSAGE

} # ::display-usage


#-------------------------------------------------------------------------------
# ::display-version
#
#   Displays version information and exits.
#
# > $1 : (optional) error code
# x $1 : same received error code
# ^ ::parse-arguments ::configure-options
#
webera::display-version() {

	cat -- <<-ENDVERSION
	webera v$_WEBERA_VERSION

	<https://github.com/andamira/webera>

	Copyright (C) 2016-2017 José Luis Cruz
	Released under the MIT license.

	Dependencies found:
	  $__SED, $__AWK, $__GREP, $__DATE
	ENDVERSION
	exit 0

} # ::display-version


#-------------------------------------------------------------------------------
# ::parse-arguments
#
#  Parses the arguments received by the script and sets/saves the options.
#
# > $@ : all the arguments passed to the script
# ^ ::main
#
webera::parse-arguments() {

	local OPTIND option value
	local optspec=':trawnF:C:T:R:O:B:dcL:G:W:S:H:P:_h-:'

	while getopts "$optspec" option; do
		case "$option" in

			# long option flags: http://stackoverflow.com/a/7680682/940200
			-)
				case "$OPTARG" in

					process-templates) webera::set-arg process-templates   ;;
					process-resources) webera::set-arg process-resources   ;;
					process-all)       webera::set-arg process-all         ;;
					preview)           webera::set-arg preview             ;;
					new-config)        webera::set-arg new-config          ;;

					file-config=*)
						webera::set-arg file-config   "${OPTARG#*=}" ;;
					config=*)
						webera::set-arg config        "${OPTARG#*=}" ;;
					dir-templates=*)
						webera::set-arg dir-templates "${OPTARG#*=}" ;;
					dir-resources=*)
						webera::set-arg dir-resources "${OPTARG#*=}" ;;
					dir-output=*)
						webera::set-arg dir-output    "${OPTARG#*=}" ;;
					dir-build=*)
						webera::set-arg dir-build     "${OPTARG#*=}" ;;

					dont-delete-output) webera::set-arg dont-delete-output ;;
					clear-log)          webera::set-arg clear-log          ;;

					log-level=*)
						webera::set-arg log-level     "${OPTARG#*=}" ;;
					log-file=*)
						webera::set-arg log-file      "${OPTARG#*=}" ;;

					browser-bin=*)
						webera::set-arg browser-bin   "${OPTARG#*=}" ;;
					server-type=*)
						webera::set-arg server-type   "${OPTARG#*=}" ;;
					server-host=*)
						webera::set-arg server-host   "${OPTARG#*=}" ;;
					server-port=*)
						webera::set-arg server-port   "${OPTARG#*=}" ;;

					help) webera::set-arg help ;;
					version) webera::set-arg version ;;

					*) [[ "$OPTERR" == 1 ]] && webera::set-arg "--$OPTARG" ;;
				esac ;;

			# short option flags

			t) webera::set-arg process-templates       ;;
			r) webera::set-arg process-resources       ;;
			a) webera::set-arg process-all             ;;
			w) webera::set-arg preview                 ;;
			n) webera::set-arg new-config              ;;

			F) webera::set-arg file-config   "$OPTARG" ;;
			C) webera::set-arg config        "$OPTARG" ;;

			T) webera::set-arg dir-templates "$OPTARG" ;;
			R) webera::set-arg dir-resources "$OPTARG" ;;
			O) webera::set-arg dir-output    "$OPTARG" ;;
			B) webera::set-arg dir-build     "$OPTARG" ;;

			d) webera::set-arg dont-delete-output      ;;
			c) webera::set-arg clear-log               ;;

			L) webera::set-arg log-level     "$OPTARG" ;;
			G) webera::set-arg log-file      "$OPTARG" ;;

			W) webera::set-arg browser-bin   "$OPTARG" ;;
			S) webera::set-arg server-type   "$OPTARG" ;;
			H) webera::set-arg server-host   "$OPTARG" ;;
			P) webera::set-arg server-port   "$OPTARG" ;;

			h) webera::set-arg help ;;

			_) webera::set-arg _ ;;  # hidden debug argument (only short)

			*) [[ "$OPTERR" != 1 || "${optspec:0:1}" == ":" ]] &&
				webera::set-arg "-$OPTARG" ;;
		esac
	done
	shift $((OPTIND-1))

} # ::parse-arguments


#-------------------------------------------------------------------------------
# ::set-arg
#
#   Sets both short and long arguments, in a centralize manner.
#
# >  $1 : the common long name of the argument
# >  $2 : (optional) the value of the argument
# x 255 : unknown argument
# ^ ::parse-arguments
#
webera::set-arg() {

	local argument="$1" value="$2"

	case "$argument" in

		# OPERATIONAL flags
		process-templates)
			_Opt_operational=true
			webera::push-arg _Opt_do_process_templates true    ;;
		process-resources)
		   _Opt_operational=true
		   webera::push-arg _Opt_do_process_resources true     ;;
		process-all)
			_Opt_operational=true
			webera::push-arg _Opt_do_process_resources true
			webera::push-arg _Opt_do_process_templates true    ;;
		preview)
			_Opt_operational=true
			webera::push-arg _Opt_do_preview_in_browser true   ;;
		new-config)
			_Opt_operational=true
			_Opt_do_generate_config_file=true
			webera::push-arg _Opt_do_generate_config_file true ;;


		# OPTIONS flags

		# Options whose name starts with an underscore `_` can only be set
		# via script arguments; they are not read from any configuration.

		file-config)
			_Opt_config_file="$value"
			webera::push-arg _Opt_config_file "$value"         ;;
		config)
			_Opt_config_string="$value"
			webera::push-arg _Opt_config_string "$value"       ;;
		clear-log)
			webera::push-arg _Opt_do_clear_log true            ;;
		dont-delete-output)
			webera::push-arg _Opt_do_delete_dir_output false   ;;

		# The following options can also be defined in configuration file,
		# but passing them as arguments to the script has a higher priority.

		dir-templates)
			webera::push-arg Opt_dir_templates "$value"        ;;
		dir-resources)
			webera::push-arg Opt_dir_resources "$value"        ;;
		dir-output)
			webera::push-arg Opt_dir_output "$value"           ;;
		dir-build)
			webera::push-arg Opt_dir_build "$value"            ;;
		log-level)
			webera::push-arg Opt_log_level "$value"            ;;
		log-file)
			webera::push-arg Opt_log_file "$value"             ;;
		browser-bin)
			webera::push-arg Opt_web_browser "$value"          ;;
		server-type)
			webera::push-arg Opt_server_type "$value"          ;;
		server-host)
			webera::push-arg Opt_server_host "$value"          ;;
		server-port)
			webera::push-arg Opt_server_port "$value"          ;;
		help)
			_Opt_do_display_usage=true ;;
		version)
			webera::display-version ;;
		_)
			_Opt_do_print_vars=true ;;
		*) # UNKNOWN
			webera::log error "ERROR: unknow argument '$argument'"
			exit 255 ;; # TODO send to log
	esac

} # ::set-arg


# ::push-arg
#
#   Pushes a key to the array of options received as args,
#   sanitizing the variable name first JIC.
#
# > $1 option key
# > $2 value received
#
webera::push-arg() {
	_Options_args_array[${1//[:=+-.,;]/_}]="${2}"
}

#-------------------------------------------------------------------------------
# ::setup-log
#
#   Sets up the log file and then writes all the pre-saved logs.
#
# ^ ::main
#
webera::setup-log() {

	local parsed_prelog

	if [[ "$_Opt_do_clear_log" == true ]]; then
		webera::log 3 warn "\nWarning: deleting previous log file '$Opt_log_file'"
		rm -- "$Opt_log_file" 2>/dev/null;
	fi

	# Restore the pre-saved log messages
	#
	# 1. filter out the lines with greater than current log level
	# 2. leave only the log message, discard the rest. TODO: restore warn|error
	# 3. bring back the newlines previously converted to BEL.
	# 4. put the log level in the date header
	#
	# shellcheck disable=SC2059
	parsed_prelog=$(printf "$_Log_presaved" \
		| $__AWK -v log_level=$Opt_log_level -F '|' '$1<=log_level' \
		| cut -d'|' -f3- \
		| tr '\a' '\n' \
		| $__SED "s/====@$/====$Opt_log_level/" \
	)
	_Log_presaved=false

	[[ -n "$parsed_prelog" ]] && webera::log "$parsed_prelog" # print what's left

} # ::setup-log


#-------------------------------------------------------------------------------
# ::log
#
#   Prints a message to the log file. Errors and warnings also to STDERR.
#
# > $1  : (optional) log_level_needed
# > $2  : (optional) log_type [warn|error]
# > $3+ : log message
# ^ (almost all functions)
#
# shellcheck disable=SC2059
webera::log() {

	local log_level_needed="$1" # First (optional) parameter
	local -ir log_level_min=1 log_level_max=3
	local -i log_level

	# must be an integer number
	if [[ "$log_level_needed" =~ ^[0-9]+$ ]]; then
		if [[ "$log_level_needed" -lt "$log_level_min" ]]; then
			log_level="$log_level_min"
		elif [[ "$log_level_needed" -gt "$log_level_max" ]]; then
			log_level="$log_level_max"
		else
			log_level="$log_level_needed"
		fi
		shift # prepare next positional parameter

	else # if not a number, use defaults
		log_level="$log_level_min"
	fi

	local log_type="$1" # Second (optional) parameter

	# must be the type
	case "$log_type" in
		error|warn)
			shift # prepare next positional parameter
			;;
		*) log_type="" ;;
	esac

	local _ifs="$IFS"; IFS=$''
	local log_msg="$*" # All that rewebera::mains is the log message
	IFS="$_ifs"

	if [[ "$_Log_presaved" == false ]]; then
		if [[ "$log_level" -le "$Opt_log_level" ]]; then
			printf "$log_msg\n" >> "$Opt_log_file"
		fi
	else
		# Pre-save this log message as a single line
		#
		# 1. replace the newlines with a BEL
		# 2. put the log level and type at the beginning
		local log_msg_1line; log_msg_1line=$(printf "$log_msg" | tr '\n' '\a') || true
		_Log_presaved+="\n$log_level|$log_type|$log_msg_1line"
	fi

	# Print errors and warnings to stderr [OPTIMIZE]
	if [[ "$log_type" == "error" || "$log_type" == "warn" ]]; then
		# 1. trim whitespace
		# 2. delete newlines
		# 3. print to STDERR
		printf "$log_msg" \
			| $__SED -e "$__Sed_trim_ws" \
			| tr -d '\n' \
			| $__AWK '{ print }' - >&2
	fi

} # ::log


#-------------------------------------------------------------------------------
# ::preview-website
#
#   Prepares the server commands, for previewing in the browser.
#
# x 5 : Server type not recognized
# ^ ::main (when the script received the `-r` flag)
#
webera::preview-website() {

	local cmd_browser

	# shellcheck disable=SC2016
	case "$Opt_server_type" in
		python)
			Opt_server_start='pushd "$Opt_dir_output"; python -m SimpleHTTPServer $Opt_server_port'
			Opt_server_stop='kill $(pgrep -f "python -m SimpleHTTPServer")'
			;;
		php)
			Opt_server_start='php -S "$Opt_server_host:$Opt_server_port" -t "$Opt_dir_output"'
			Opt_server_stop='kill $(pgrep -f "php -S $Opt_server_host")'
			;;
		none) # useful when not using `dir/index.html` structure
			Opt_server_start=""
			Opt_server_stop=""
			;;
		custom) # for when a server is already running, or custom Opt_server_start
			;;
		*)
			webera::log 2 error "ERROR: Not recognized Opt_server_type='$Opt_server_type'"
			exit 5
			;;
	esac

	printf 'Loading website in "%s"...\n' "$Opt_web_browser"

	if [[ "$Opt_server_type" == "none" ]]; then
		cmd_browser="$Opt_web_browser file://$($__READLINK -f $Opt_dir_output) &"
	else
		cmd_browser="$Opt_web_browser http://$Opt_server_host:$Opt_server_port &"
	fi

	sleep 1s && eval "$cmd_browser" >&2 2>/dev/null
	if [[ -n "$Opt_server_start" ]]; then
		printf '(Use CTRL+C to stop the "%s" web server)\n' \
			"$Opt_server_type"
		printf 'Opt_server_start=%s' "$Opt_server_start"
		eval "$Opt_server_stop >&2 2>/dev/null"; eval "$Opt_server_start"
	fi

} # ::preview-website


#-------------------------------------------------------------------------------
# ::delete-directories
#
#   Deletes Opt_dir_build and Opt_dir_output if there is pending processing.
#
# ^ ::main
#
webera::delete-directories() {

	[[ "$Opt_do_delete_dir_build" == true ]] &&
		rm -rf -- "$Opt_dir_build" 2>/dev/null

	if [[ "$_Opt_do_delete_dir_output" == true ]] && \
		[[ $_Opt_do_process_resources == true \
		|| $_Opt_do_process_templates == true ]]; then
		rm -rf -- "$Opt_dir_output" 2>/dev/null
	fi

} # ::delete-directories


#-------------------------------------------------------------------------------
# ::read-config
#
#   Reads some configuration from a file or a string,
#   and joins it together to a common source.
#
# > $1 : $config_type [file|string]
# > $3 : $config_pointer will be interpreted as the file name if config_type=file,
#        or as the variable name if config_type=string
# x 10 : unknown config type
# ^ ::main
#
webera::read-config() {

	local config_type="$1" config_pointer="$2"
	local read_config config_line

	if [[ "$config_type" == "string" ]]; then
		if [[ -n "${!config_pointer}" ]]; then # string's not empty
			webera::log 3 "Reading settings passed as an argument."
			read_config="$(printf '%s' "${!config_pointer}" \
				| $__SED -e "$__Sed_trim_ws" \
				| $__SED -e "$__Sed_del_comments" -e "$__Sed_del_empty_lines" \
				| $__SED -e "$__Sed_join_split_lines" \
			)"$'\n'
			_Config_whole+="$read_config"
			webera::debug-vars-add-config strn "" "$read_config"
		fi

	elif [[ "$config_type" == "file" ]]; then
		if [[ -f "$config_pointer" ]]; then # file exists

			if [[ $_Opt_do_generate_config_file == true && $config_pointer == "$_Opt_config_file" ]]; then
				webera::log 2 warn "Warning: automatic override of an existing " \
					"local config file ('$config_pointer') is not permitted."
			else
				webera::log 3 "Reading settings from file '$config_pointer'"
				read_config="$(sed -e "$__Sed_trim_ws" "$config_pointer" \
					| $__SED -e "$__Sed_del_comments" -e "$__Sed_del_empty_lines" \
					| $__SED -e "$__Sed_join_split_lines" \
				)"$'\n'
				_Config_whole+="$read_config"
				webera::debug-vars-add-config file "$config_pointer" "$read_config"
			fi

		else # config file doesn't exist
			# it's the config file of the project
			if [[ "$config_pointer" == "$_Opt_config_file" ]]; then
				# stop if printing debug info
				[[ "$_Opt_do_print_vars" == true ]] && return 0

				if [[ "$_Opt_do_generate_config_file" == true ]]; then
					webera::generate-config
				else
					webera::log 3 warn "Warning: project's config file " \
						"'$_Opt_config_file' doesn't exist."
				fi
			fi
		fi
	else
		webera::log error "Error: unknown config type"
		exit 10
	fi

} # ::read-config


#-------------------------------------------------------------------------------
# ::configure-options
#
#   Parses the configuration options and overrides the default options with:
#   1 - the joint configuration and 2 - the passed arguments, in that order.
#
# ^ ::main
#
webera::configure-options() {

	local settings_list setting option_name setting_value setting_previous

	# Create a list of all the 'config' operations
	settings_list="$(printf '%s' "$_Config_whole" \
		| $__GREP "^$__Ws*config$__Ws*:" )"

	if [[ -n "$settings_list" ]]; then
		webera::log "\nConfiguring settings...\n$__Hl"

		local _ifs="$IFS"; IFS=$'\n'
		for setting in $settings_list; do
			# TODO: sanitize received data
			option_name=$(printf '%s' "$setting" \
				| cut -d':' -f2 \
				| $__SED -e "$__Sed_trim_ws")
			setting_value=$(printf '%s' "$setting" \
				| cut -d':' -f3- \
				| $__SED -e "$__Sed_trim_ws")

			[[ -n "${!option_name}" ]] &&
				setting_previous="(previous=${!option_name})"

			webera::log "${__In}setting: $option_name=$setting_value " \
				"$setting_previous"

			# Read (only public) settings from file
			if [[ "$setting" != _* ]]; then
				# Adapt name to inner style (lowercase, 1st letter UPPERCASE)
				option_name="Opt_${option_name,,}"
				printf -v "$option_name" '%s' "$setting_value"
			fi
		done
		IFS="$_ifs"
	fi

	local opt opt_list

	for opt in "${!_Options_args_array[@]}"; do
		# Override the option variable with the parsed argument
		printf -v "$opt" '%s' "${_Options_args_array[$opt]}"
		# add it to a temporary list
		opt_list+="$opt=${_Options_args_array[$opt]}"$'\n'
	done
	# Add to the list the prepared prepared variable names
	__Vars_webera+=$'\n'"$(webera::debug-vars-prepare-name "$opt_list" args)"

} # ::configure-options


#-------------------------------------------------------------------------------
# ::generate-config
#
#   Generates a config file, writing down the options modified via arguments.
#
# ^ ::main (when the script received the `-n` flag)
#
webera::generate-config() {

	local config_lines=() option line

	for option in "${!_Options_args_array[@]}"; do

		# Write (only public) options to config file
		if [[ "$option" != _* ]]; then
			# Make name UPPERCASE and remove Opt_ prefix
			local opt=${option#Opt_}
			config_lines+=("config : ${opt^^} : ${_Options_args_array[$option]}")
		fi
	done

	for line in "${config_lines[@]}"; do
		printf '%s\n' "$line" >> "$_Opt_config_file"
	done
	touch "$_Opt_config_file"

} # ::generate-config


#-------------------------------------------------------------------------------
# ::read-config-commands
#
#   Reads the configuration commands for processing templates and resources.
#
# ^ ::main
#
webera::read-config-commands() {

	local commands_list cmd commands_num command_name command_action

	commands_list="$(printf '%s' "$_Config_whole" | $__GREP "^$__Ws*command$__Ws*:" )"

	if [[ -n "$commands_list" ]]; then
		commands_num=$(printf '%s\n' "$commands_list" | wc -l )
		webera::log 1 "\nParsing commands...\n$__Hl"
		webera::log 1 "${__In}Found $commands_num defined command:"
	else return 0; fi

	local _ifs="$IFS"; IFS=$'\n'
	for cmd in $commands_list; do # [OPTIMIZE]
		command_name=$(printf '%s' "$cmd" \
			| cut -d':' -f2 \
			| $__SED -e "$__Sed_trim_ws" )
		command_action=$(printf '%s' "$cmd" \
			| cut -d':' -f3- \
			| $__SED -e "$__Sed_trim_ws" )

		_Defined_cmd_map["$command_name"]="$command_action"

		webera::log 2 "${__In}$command_name='$command_action'"
	done
	IFS="$_ifs"

} # ::read-config-commands


#-------------------------------------------------------------------------------
# ::process-resources
#
#   Parses the configuration and executes the resource operations.
#
# < 8 : no resources directory found
# ^ ::main (when the script received the `-r` flag)
#
webera::process-resources() {

	local resource_op_list resource_op_num resource_op
	local operation file_orig file_target cmd

	webera::log 1 "\nProcessing resources...\n$__Hl"

	if [[ ! -d "$Opt_dir_resources" ]]; then
		webera::log 1 error "No resources dir '$Opt_dir_resources' found."
		return 8
	fi

	resource_op_list="$(printf '%s' "$_Config_whole" \
		| $__GREP "^$__Ws*resource$__Ws*:" )"
	resource_op_num=$(printf '%s\n' "$resource_op_list" \
		| $__SED "$__Sed_del_empty_lines" \
		| wc -l )
	webera::log 1 "${__In}Found $resource_op_num operations on resources:"

	local _ifs="$IFS"; IFS=$'\n'
	for resource_op in $resource_op_list; do # [OPTIMIZE]
		operation=$(printf '%s' "$resource_op" \
			| cut -d':' -f2 \
			| $__SED -e "$__Sed_trim_ws" )
		file_orig=$(printf '%s' "$resource_op" \
			| cut -d':' -f3 \
			| $__SED -e "$__Sed_trim_ws" )
		file_target=$(printf '%s' "$resource_op" \
			| cut -d':' -f4 \
			| $__SED -e "$__Sed_trim_ws" )

		webera::log 1 "${__In}$operation: $file_orig > $file_target"

		if [[ ! -e "$Opt_dir_resources/$file_orig" ]]; then
			webera::log 1 error "${__In}ERROR: '$file_orig' don't exist"
			continue # XXX do break instead?
		fi

		case "$operation" in
			"copy")
				mkdir -p -- "$Opt_dir_output/$Opt_dir_resources/$(dirname "$file_target")"
				cp -r -- "$Opt_dir_resources/$file_orig" \
					"$Opt_dir_output/$Opt_dir_resources/$file_target"
				;;
			*)
				# On custom cmds, {PATHS} tags are adapted for resources
				if [[ -n "${_Defined_cmd_map[$operation]}" ]]; then

					cmd=$(printf '%s' "${_Defined_cmd_map[$operation]}" \
						| $__SED "s|{ORIGIN}|$Opt_dir_resources/$file_orig|g" \
						| $__SED "s|{BUILD}|$Opt_dir_build/$file_orig|g" \
						| $__SED "s|{TARGET}|$Opt_dir_output/$Opt_dir_resources/$file_target|g")

					# Create target paths
					if [[ "${_Defined_cmd_map[$operation]}" == *"{BUILD}"* ]]; then
						mkdir -p -- "$(dirname "$Opt_dir_build/$file_target")"
					fi
					if [[ "${_Defined_cmd_map[$operation]}" == *"{TARGET}"* ]]; then
						mkdir -p -- "$(dirname \
							"$Opt_dir_output/$Opt_dir_resources/$file_target")"
					fi

					webera::log 3 "${__In}Executing: $cmd"
					eval "$cmd"
				else
					webera::log 1 error \
						"${__In}ERROR: operation '$operation' not recognized"
				fi
				;;
		esac
	done
	IFS="$_ifs"

} # ::process-resources


#-------------------------------------------------------------------------------
# ::process-templates
#
#   Parses the configuration and executes the template operations.
#
# < 9 : no templates directory found
# ^ ::main (when the script received the `-t` flag)
#
webera::process-templates() {

	local template_op_list template_op_num template_op
	local operation file_orig file_target cmd

	webera::log 1 "\nProcessing templates...\n$__Hl"

	if [[ ! -d "$Opt_dir_templates" ]]; then
		webera::log 1 error "No templates dir '$Opt_dir_templates' found."
		return 9
	fi

	template_op_list="$(printf '%s' "$_Config_whole" \
		| $__GREP "^$__Ws*template$__Ws*:" )"

	template_op_num=$(printf '%s\n' "$template_op_list" \
		| $__SED "$__Sed_del_empty_lines" \
		| wc -l )
	webera::log 1 "${__In}Found $template_op_num operations on templates:"

	local _ifs="$IFS"; IFS=$'\n'
	for template_op in $template_op_list; do
		operation=$(printf '%s' "$template_op" \
			| cut -d':' -f2 \
			| $__SED -e "$__Sed_trim_ws" )
		file_orig=$(printf '%s'  "$template_op" \
			| cut -d':' -f3 \
			| $__SED -e "$__Sed_trim_ws" )
		file_target=$(printf '%s' "$template_op" \
			| cut -d':' -f4 \
			| $__SED -e "$__Sed_trim_ws" )

		webera::log 1 "${__In}$operation: $file_orig > $file_target"

		case "$operation" in
			"route")
				if [[ -n "$file_orig" && -n "$file_target" ]]; then
					# A path ending in `/`, will be a dir_name/index.html
					if [[ "$file_target" == */ ]]; then
						mkdir -p -- "${Opt_dir_output}/${file_target}"
						webera::render-template "$file_orig" > \
							"${Opt_dir_output}/${file_target}/index.html"
					else
						mkdir -p -- "$(dirname "${Opt_dir_output}/${file_target}")"
						webera::render-template "$file_orig" > \
							"${Opt_dir_output}/${file_target}"
					fi
				else
					webera::log 1 error "${__In}ERROR: missing arguments for" \
						"'template:route' operation"
				fi
				;;

			*)
				# On custom cmds, the {PATHS} tags are adapted for templates
				if [[ -n "${_Defined_cmd_map[$operation]}" ]]; then

					cmd=$(printf '%s' "${_Defined_cmd_map[$operation]}" \
						| $__SED "s|{ORIGIN}|$Opt_dir_templates/$file_orig|g" \
						| $__SED "s|{BUILD}|$Opt_dir_build/$file_orig|g" \
						| $__SED "s|{TARGET}|$Opt_dir_output/$file_target|g" \
					)

					# Create target paths
					if [[ "${_Defined_cmd_map[$operation]}" == *"{BUILD}"* ]]; then
						mkdir -p -- "$(dirname "$Opt_dir_build/$file_target")"
					fi
					if [[ "${_Defined_cmd_map[$operation]}" == *"{TARGET}"* ]]; then
						mkdir -p -- \
							"$(dirname "$Opt_dir_output/$Opt_dir_resources/$file_target")"
					fi

					webera::log 3 "${__In}Executing: $cmd"
					eval "$cmd"
				else
					webera::log 1 error \
						"${__In}ERROR: operation '$operation' not recognized"
				fi
				;;
		esac
	done
	IFS="$_ifs"

} # ::process-templates


#-------------------------------------------------------------------------------
# ::parse-template-includes
#
#   Recursively parses a template for include directives, and then
#   joins all the parts together in a single template.
#
# > $1 : template_file_name
# <  7 : No template found
# x  3 : Maximum nesting level overflow
# ^ ::render-template
#
webera::parse-template-includes() {

	local template_file_name=$1
	local template_content directive directives_include inc_file_name inc_file_content

	((_Nesting_level++))

	if [[ "$_Nesting_level" -gt "$Opt_nesting_max" ]]; then
		webera::log 1 error "${__In}ERROR: max nesting level ($Opt_nesting_max)" \
			"reached for template $template_file_name"
		exit 3
	fi

	# Parse template
	local template_file="${Opt_dir_templates}/$template_file_name"
	if [[ -f "$template_file" ]]; then
		template_content="$(<"$template_file")"
	else
		webera::log 1 error "${__In}ERROR: No template found '$template_file'"
		return 7
	fi
	directives_include=$($__GREP -Po "<!--$__Ws*%include$__Ws*:.*?-->" \
		"$template_file") # [INC01]

	# Remove duplicates
	if [[ -n "$directives_include" ]]; then
		directives_include=$(printf '%s' "$directives_include" | uniq)
	fi

	local _ifs="$IFS"; IFS=$'\n'
	for directive in $directives_include; do
		inc_file_name=$(webera::get-directive-content "$directive" '%include')
		webera::log 2 "${__In2}include: '$inc_file_name'"

		# Parse included template for further includes
		inc_file_content="$(webera::parse-template-includes "${inc_file_name}")"

		# Mass-replace directive with template contents
		template_content="${template_content//$directive/$inc_file_content}"
	done
	IFS="$_ifs"

	((_Nesting_level--))

	printf '%s' "$template_content"

} # ::parse-template-includes


#-------------------------------------------------------------------------------
# ::render-template
#
#   Parses the template, processes the directives and renders the html file.
#
# > $1 : template_file_name
# ^ ::process-templates (when parsing the 'route' command)
#
webera::render-template() {

	local template_file_name="$1"

	local template_text directives_set directives_cmd directives_setcmd
	local directive setVarVal setVar setValue cmd cmd_output
	local set_cmd_var set_cmd_value set_cmd set_cmd_output
	local -i cmd_output_len _max_output_len=50 # in characters

	template_text="$(webera::parse-template-includes "$template_file_name")"

	# text comments
	#
	# <!-- // Comment -->
	#
	template_text=$(printf '%s' "$template_text" \
		| $__SED -e :a -re "s/<!--$__Ws*\/\/.*?-->//g;/<!--\/\//N;//ba")

	local _ifs="$IFS"; IFS=$'\n'

	# set variables
	#
	# <!-- %set : VARIABLE=something -->
	# <!-- @VARIABLE -->
	#
	directives_set=$(printf '%s' "$template_text" \
		| $__GREP -Po "<!--$__Ws*%set$__Ws*:.*?-->") # [INC01]

	for directive in $directives_set; do
		setVarVal=$(webera::get-directive-content "$directive" '%set')
		setVar="${setVarVal%%=*}"
		setValue="${setVarVal#*=}"
		webera::log 3 "${__In3}set: $setVar = $setValue"

		# Cross-platform syntax to replace including newlines
		# http://stackoverflow.com/a/1252191
		template_text=$(printf '%s' "$template_text" \
			| $__SED -e ":a" -e "N" -e "\$!ba" -e "s/$directive\n\?//g")
		template_text=$(printf '%s' "$template_text" \
			| $__SED -e ":a" -e "N" -e "\$!ba" \
			-e "s/<!--$__Ws*@$setVar$__Ws*-->\n\?/$setValue/g")
	done

	# execute commands, render output
	#
	# <!-- %cmd : ls -l -->
	#
	directives_cmd=$(printf '%s' "$template_text" \
		| $__GREP -Po "<!--$__Ws*%cmd$__Ws*:.*?-->") # [INC01]

	for directive in $directives_cmd ; do
		cmd=$(webera::get-directive-content "$directive" '%cmd')
		cmd_output=$(eval "$cmd")
		webera::log 3 "${__In2}cmd: $cmd"

		cmd_output_len=$(printf "%s" "$cmd_output" | wc -c)

		if [[ "$cmd_output_len" -le "$_max_output_len" ]]; then
			webera::log 3 "${__In3}=: $cmd_output"
		else
			webera::log 3 "${__In3}=: $(printf '%s' "$cmd_output" \
				| tr '\n' ' ' \
				| head -c$_max_output_len) (...) +" \
				"$((cmd_output_len-_max_output_len)) chars"
		fi

		# Substitute the directive in the template with the command output
		# http://stackoverflow.com/a/40749641/940200
		template_text=$($__AWK -v repl="$cmd_output" 'FNR==NR {
				a = a $0; next
			}
			n = index($0, a) {
				$0 = substr($0, 1, n-1) repl substr($0, n+length(a))
			} 1' <(printf '%s\n' "$directive") <(printf '%s' "$template_text")
		)
	done

	# set variables to commands output
	#
	# <!-- %setcmd : VARIABLE=ls -l -->
	# <!-- @VARIABLE -->
	#
	directives_setcmd=$(printf '%s' "$template_text" \
		| $__GREP -Po "<!--$__Ws*%setcmd$__Ws*:.*?-->") # [INC01]

	for directive in $directives_setcmd; do
		set_cmd=$(webera::get-directive-content "$directive" '%setcmd')
		set_cmd_var="${set_cmd%%=*}"
		set_cmd_value="${set_cmd#*=}"
		set_cmd_output=$(eval "$set_cmd_value")
		webera::log 3 "${__In2}setcmd: $set_cmd_var = $set_cmd_value"

		# Delete the directive from the template
		template_text=$($__AWK -v 'FNR==NR {
				a = a $0; next
			}
			n = index($0, a) {
				$0 = substr($0, 1, n-1) substr($0, n+length(a))
			} 1' <(printf '%s\n' "$directive") <(printf '%s' "$template_text")
		)
		# Replace all the set variables with the command output
		template_text=$(printf '%s' "$template_text" \
			| $__SED -e ":a" -e "N" -e "\$!ba" \
			-e "s/<!--$__Ws*@$set_cmd_var$__Ws*-->\n\?/$set_cmd_output/g")
	done

	IFS="$_ifs"

	webera::log 3

	printf "%s" "$template_text"

} # ::render-template


#-------------------------------------------------------------------------------
# ::get-directive-content
#
#   Checks for dependencies and displays pertinent information.
#
# > $1 : whole directive
# > $2 : directive identifier (e.g. %include)
# ^ ::render-template
#
webera::get-directive-content() {

	printf '%s' "$1" \
		| $__SED -n -e "s/<\!--$__Ws*$2$__Ws*:$__Ws*\(.*\)$__Ws*-->/\1/p" \
		| $__SED -e "s/$__Ws*$//"

} # ::get-directive-content


#-------------------------------------------------------------------------------
# ::check-compatibility
#
#   Checks for dependencies and displays pertinent information.
#
# x 6 : bash version too old
# ^ ::main
#
webera::check-compatibility() {

	# Bash version >= 4
	if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
		printf '%s\n' "Bash version >=4 needed. Current version is $BASH_VERSION"

		if [[ "$(uname)" == 'Darwin' ]]; then
			printf 'You can install it with Brew (http://brew.sh)\n like this:'
			printf 'brew install bash\n'
		fi
		exit 6
	fi

	# prefer the GNU version of the Unix commands used, specially in Mac OS X
	__SED="$(webera::find-gnu-cmd sed)"
	__AWK="$(webera::find-gnu-cmd  awk)"
	__GREP="$(webera::find-gnu-cmd grep)"
	__DATE="$(webera::find-gnu-cmd date)"
	__READLINK="$(webera::find-gnu-cmd readlink)"

} # ::check-compatibility


#-------------------------------------------------------------------------------
# ::find-gnu-cmd
#
#   Returns the resolved command, preferring the GNU versions
#   and falling back to the standard version when not found.
#
# > $1 : command binary
# ^ ::check-compatibility
#
webera::find-gnu-cmd() {

	local cmd_default="$1"
	local cmd_gnu="g$cmd_default"

	if [[ "$(which "$cmd_gnu" 2> /dev/null)" ]]; then
		printf '%s' "$cmd_gnu"
	else
		printf '%s' "$cmd_default"
	fi

} # ::find-gnu-cmd


#-------------------------------------------------------------------------------
# ::setup-debugging
#
#   Enables xtrace if WEBERA_DEBUG has been defined, and sets a nice formatting.
#
# ^ ::main
#
# shellcheck disable=SC2016
webera::setup-debugging() {

	local ps4_date='[$(($($__DATE "+%s%3N")-__Time_stamp))ms]' # [INC02]
	local ps4_line='L$LINENO'
	local ps4_func='${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

	[[ -n "$WEBERA_DEBUG" ]] && set -o xtrace && \
		export PS4="+ $ps4_date $ps4_line $ps4_func"

} # ::setup-debugging


#-------------------------------------------------------------------------------
# ::debug-print-vars
#
#   Prints all the script "global" settings and data, public and private.
#
# ^ ::main
#
webera::debug-print-vars() { printf '%s\n' "$__Vars_webera"; }


#-------------------------------------------------------------------------------
# ::debug-save-default-vars
#
#   Saves all the default declared pseudo-global variables.
#
# ^ ::main
#
webera::debug-save-default-vars() {

	# return the variables not common to both lists
	local declared_vars; declared_vars=$( $__GREP -vFf \
		<(printf '%s' "$__Vars_before") <(printf '%s' "$__Vars_after") )

	# saves them after sanitizing the names
	printf -v __Vars_webera '%s' \
		"$(webera::debug-vars-prepare-name "$declared_vars" vdef)"

	unset __Vars_before; unset __Vars_after;

} # ::debug-save-default-vars


#-------------------------------------------------------------------------------
# ::debug-vars-prepare-name
#
#   Removes the Opt_ prefix, UPPERCASES `variable=`, and adds the origin prefix.
#
# > $1 : the lines in `variable=value` format
# > $2 : the variable origin prefix [vdef|args|file|strn]
#
webera::debug-vars-prepare-name() {

	$__SED -e 's/^\(_\?\)Opt_/\1/' \
		-e 's/[^=]*/\U&/' \
		-e "s/^/[$2]::/" \
		<(printf '%s' "$1")

} # ::debug-vars-prepare-name


#-------------------------------------------------------------------------------
# ::debug-vars-add-config
#
#   Parses configuration, extracts the config variables and appends them
#   to __Vars_webera in the correct format, using the provided arguments.
#
# > $1 : the variable origin prefix [vdef|args|file|strn]
# > $2 : the variable path (only for files)
# > $3 : configuration
# ^ webera::read-config
#
webera::debug-vars-add-config() {

	local var_orig="$1" var_path="$2" configuration="$3"
	local config_line config_var config_value

	local _ifs="$IFS"; IFS=$'\n'
	for config_line in $(printf '%s' "$configuration" \
		| $__GREP '^config' \
		| cut -d ':' -f2- \
		| $__SED "s/$__Ws*:$__Ws*/=/" \
		| $__SED "$__Sed_trim_ws" \
		); do
		if [[ "$config_line" != _* ]]; then # only read public variables
			config_var="${config_line%=*}"
			config_value="${config_line#*=}"
			config_line="${config_var^^}=$config_value"
			__Vars_webera+=$'\n'"[$var_orig]:$var_path:$config_line"
		fi
	done
	IFS="$_ifs"

} # ::debug-vars-add-config


#-------------------------------------------------------------------------------
# ::elapsed-time
#
#   Prints the spent time on the script, in milliseconds.
#
# > $1 : if true, prints the time beautified
#
#
webera::elapsed-time() {

	local -ir time_stamp_final="$($__DATE '+%s%3N')"
	local -ir time_elapsed="$((time_stamp_final-__Time_stamp))"
	if [[ "$1" == true ]]; then
		printf '%s' "$(webera::beautify-time "$time_elapsed")"
	else
		printf '%s' "$time_elapsed"
	fi

} # ::elapsed-time


#-------------------------------------------------------------------------------
# ::beautify-time
#
#   Tries to format a time in milliseconds into a human readable text string
#   showing the days, hours, minutes and/or seconds contained in that time.
#
# > $1 : time in milliseconds
# e    : time beautified
#
webera::beautify-time() {

	local -ir ms="$1"
	local -ir s="$((ms/1000%60))"
	local -ir m="$((ms/60000%60))"
	local -ir h="$((ms/3600000%24))"
	local -ir d="$((ms/86400000))"

	local time_str

	[[ "$d" -gt 0 ]] && time_str+="${d}d"
	[[ "$h" -gt 0 || -n "$time_str" ]] && time_str+="${h}h "
	[[ "$m" -gt 0 || -n "$time_str" ]] && time_str+="${m}m "
	[[ -n "$time_str" ]] && time_str+="${s}s " # shows seconds if time > 1m
	[[ "$m" -lt 1 && -z "$time_str" ]] && time_str+="${ms}ms "

	printf '%s' "${time_str}"

} # ::beautify-time


[[ "$0" == "${BASH_SOURCE[0]}" ]] && webera::main "$@" # Run if not sourced
