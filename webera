#!/usr/bin/env bash
# shellcheck disable=SC2016
#
#         name : webera
#  description : a handy static website generator
#   repository : https://github.com/andamira/webera
#       author : José Luis Cruz © 2016-2017
#      license : MIT
_WEBERA_VERSION=0.1.65


#-------------------------------------------------------------------------------
# main
#
# argument: $@ : all the arguments passed to the script
#
main() {

	## INNER SETUP-A

	# Binaries found for Unix commands employed
	declare __SED __AWK __GREP __DATE __READLINK

	__checkCompatibility
	local -ir __WEBERA_TIME_STAMP="$($__DATE '+%s%3N')" # [INC02]
	__setupDebugging

	# prepare to save a list of the default settings
	declare __VARS_WEBERA __VARS_BEFORE __VARS_AFTER
	__VARS_BEFORE=$(set -o posix ; set | $__AWK -F= '{print $1"="}' )


	## CONFIGURABLE SETTINGS
	#
	# NOTE-1: Variables starting with an underscore can't be configured
	# from a file|string, but they can be set using script arguments.
	# NOTE-2: Variables that don't have an argument associated they
	# can only be changed via config file|string.

	# Paths
	local DIR_TEMPLATES=tem               # -T
	local DIR_RESOURCES=res               # -R
	local DIR_OUTPUT=out                  # -O
	local DIR_BUILD=build                 # -B
	local _CONFIG_FILE=.weberarc          # -F
	local _CONFIG_STRING=''               # -S

	# Web Browser
	local WEB_BROWSER="firefox"           # -W
	local SERVER_TYPE="python"            # -S
	local SERVER_HOST="localhost"         # -H
	local -i SERVER_PORT=8192             # -P
	local SERVER_START=""
	local SERVER_STOP=""

	# Log
	local LOG_FILE=log.txt                # -G
	local _OPTION_LOG_CLEAR=false         # -c
	local -i OPTION_LOG_LEVEL=0           # -L [0-3]

	# Delete output & build directories
	local _OPTION_DELETE_DIR_OUTPUT=true  # -d
	local OPTION_DELETE_DIR_BUILD=true

	# Misc
	local -i NESTING_MAX=8


	## NON-CONFIGURABLE DATA

	# statuses
	local _OPERATIONAL=false              # -trawn
	local _DO_PROCESS_TEMPLATES=false     # -ta
	local _DO_PROCESS_RESOURCES=false     # -ra
	local _DO_PREVIEW_IN_BROWSER=false    # -w
	local _DO_GENERATE_CONFIG_FILE=false  # -n

	# arrays
	declare -A _ARG_OPTIONS
	declare -A _DEFINED_CMD_MAP

	local -i _NESTING_LEVEL=0

	local _CONFIG_JOINT="" # where to save all the configurations
	local _PRELOG="" # where log is saved before there's a logfile

	local -r _DATE_START="$($__DATE '+%Y-%m-%d %H:%M:%S' \
		-d @"${__WEBERA_TIME_STAMP:0:10}")" # [INC03]


	## INNER SETUP-B
	# save the list of the default settings
	__VARS_AFTER="$(set -o posix ; set | $__SED '/^'\''/d' )"
	printf -v __VARS_WEBERA '%s' "$($__GREP -vFf \
		<(printf '%s' "$__VARS_BEFORE") <(printf '%s' "$__VARS_AFTER") \
		| $__SED 's/^/[vdef]::/' )"
	unset __VARS_BEFORE; unset __VARS_AFTER;
	local __DO_PRINT_VARS=false           # -_


	## STRING CONSTANTS

	# log indentation and formatting
	declare -r _IN="  " _IN2="    " _IN3="      "
	local -r _HEADING='------------------------------------------------------'

	# reusable regexp patterns
	local -r _WS="[[:space:]]" # whitespace
	local -r _SED_TRIM_WS="s/^$_WS*//;s/$_WS*$//"
	local -r _SED_DEL_COMMENTS="/^$_WS*#.*/d" # starting in #
	local -r _SED_DEL_EMPTYLINES="/^$_WS*$/d"
	local -r _SED_JOIN_SPLITLINES=':x; /\\$/ {N; s/\\\n//; tx}' # ending in \


	## MAIN PROCESS

	log 1 "\n===============[$_DATE_START]==============@\n"

	parseArguments "$@"

	# Read the configuration files & string
	[[ "$_CONFIG_FILE" != "/etc/weberarc" ]] \
		&& readConfig file "/etc/weberarc"
	[[ "$_CONFIG_FILE" != "$HOME/.weberarc" ]] \
		&& readConfig file "$HOME/.weberarc"
	readConfig file "$_CONFIG_FILE"
	readConfig string '_CONFIG_STRING'

	configureSettings

	[[ "$_DO_USAGE" == true ]] && usage
	[[ "$__DO_PRINT_VARS" == true ]] && __varsPrint && exit "$?"

	setupLog

	if [[ "$_OPERATIONAL" == false ]]; then
		usage 1
	fi

	deleteDirectories

	readConfigCommands

	[[ "$_DO_PROCESS_RESOURCES" == true ]] && processResources
	[[ "$_DO_PROCESS_TEMPLATES" == true ]] && processTemplates

	log "Total elapsed time: $(__timeElapsed true)"

	[[ "$_DO_PREVIEW_IN_BROWSER" == true ]] && previewWebsite
	exit 0

} #main()


#-------------------------------------------------------------------------------
# usage
#
#   Displays Usage information.
#
# argument: $1 : (optional) error code
#     exit: $1 : same received error code
#   parent: parseArguments configureSettings
#
usage() {
	cat -- <<-ENDUSAGE
	Usage: $(basename "$0") -[trawn] [other options]

	> a handy static website generator <

	INSTRUCTIONS

	1. At least one OPERATIVE FLAG is needed in order for the script to run.
	2. Mandatory arguments to long options, are mandatory for short options too.

	OPERATIVE FLAGS              ...

	  -t, --process-templates    process the templates
	  -r, --process-resources    process the resources
	  -a, --process-all          process both the templates and the resources
	  -w  --preview              preview website in the web browser
	  -n  --new-config           generate a new configuration file

	OPTION FLAGS                 ... (default value)

	  -F, --file-config=FILE     indicate the configuration file ($_CONFIG_FILE)
	  -C, --config=STRING        pass the configuration as a string ($_CONFIG_STRING)

	  -T, --dir-templates=DIR    indicate the templates directory ($DIR_TEMPLATES)
	  -R, --dir-resources=DIR    indicate the resources directory ($DIR_RESOURCES)
	  -O, --dir-output=DIR       indicate the output directory ($DIR_OUTPUT)
	  -B, --dir-build=DIR        indicate the build directory ($DIR_BUILD)
	  -d, --dont-delete-output   don't delete the output dir ($_OPTION_DELETE_DIR_OUTPUT)

	  -L, --log-level=LEVEL      log level [0=none|1|2|3] ($OPTION_LOG_LEVEL)
	  -c, --clear-log            clear the previous log file ($_OPTION_LOG_CLEAR)
	  -G, --logfile=FILE         log file ($LOG_FILE)

	  -W, --browser-bin=BIN      web browser binary ($WEB_BROWSER)
	  -S, --server-type=TYPE     server type [none|php|python|custom] ($SERVER_TYPE)
	  -H, --server-host=HOST     server host ($SERVER_HOST)
	  -P, --server-port=PORT     port number ($SERVER_PORT)

	  -h, --help                 display this help and exit
	      --version              show version info and exit

	ENDUSAGE
	[[ -n "$1" ]] && exit "$1"

} #usage()


#-------------------------------------------------------------------------------
# versionInfo
#
#   Displays version information and exits
#
# argument: $1 : (optional) error code
#     exit: $1 : same received error code
#   parent: parseArguments configureSettings
#
versionInfo() {
	cat -- <<-ENDVERSION
	webera v$_WEBERA_VERSION

	<https://github.com/andamira/webera>

	Copyright (C) 2016-2017 José Luis Cruz
	Released under the MIT license.

	Dependencies found:
	  $__SED, $__AWK, $__GREP, $__DATE
	ENDVERSION
	exit 0

} #versionInfo()


#-------------------------------------------------------------------------------
# parseArguments
#
#  Parses the arguments received by the script and sets/saves the options.
#
# argument:   $@ : all the arguments passed to the script
#     exit:  255 : when the argument is unknown
#   parent: main
#
parseArguments() {
	local OPTIND option value
	local optspec=':trawnF:C:T:R:O:B:dcL:G:W:S:H:P:_h-:'

	while getopts "$optspec" option; do
		case "$option" in

			# long options: http://stackoverflow.com/a/7680682/940200
			-)
				case "$OPTARG" in

					process-templates) setArg process-templates ;;
					process-resources) setArg process-resources ;;
					process-all)       setArg process-all       ;;
					preview)           setArg preview           ;;
					new-config)        setArg new-config        ;;

					file-config=*)    setArg file-config   "${OPTARG#*=}" ;;
					config=*)         setArg config        "${OPTARG#*=}" ;;
					dir-templates=*)  setArg dir-templates "${OPTARG#*=}" ;;
					dir-resources=*)  setArg dir-resources "${OPTARG#*=}" ;;
					dir-output=*)     setArg dir-output    "${OPTARG#*=}" ;;
					dir-build=*)      setArg dir-build     "${OPTARG#*=}" ;;

					dont-delete-output) setArg dont-delete-output ;;
					clear-log)          setArg clear-log          ;;

					log-level=*)   setArg log-level   "${OPTARG#*=}" ;;
					log-file=*)    setArg log-file    "${OPTARG#*=}" ;;

					browser-bin=*) setArg browser-bin "${OPTARG#*=}" ;;
					server-type=*) setArg server-type "${OPTARG#*=}" ;;
					server-host=*) setArg server-host "${OPTARG#*=}" ;;
					server-port=*) setArg server-port "${OPTARG#*=}" ;;

					help) setArg help ;;
					version) setArg version ;;

					*)  # error
						if [[ "$OPTERR" == 1 ]]; then
							log error "ERROR: unknown argument '--$OPTARG'"
							# TODO FIXME: clear error on non-option argument (without =*)
							exit 255
						fi ;;
				esac ;;

			# short flags

			t) setArg process-templates       ;;
			r) setArg process-resources       ;;
			a) setArg process-all             ;;
			w) setArg preview                 ;;
			n) setArg new-config              ;;

			F) setArg file-config   "$OPTARG" ;;
			C) setArg config        "$OPTARG" ;;

			T) setArg dir-templates "$OPTARG" ;;
			R) setArg dir-resources "$OPTARG" ;;
			O) setArg dir-output    "$OPTARG" ;;
			B) setArg dir-build     "$OPTARG" ;;

			d) setArg dont-delete-output      ;;
			c) setArg clear-log               ;;

			L) setArg log-level     "$OPTARG" ;;
			G) setArg log-file      "$OPTARG" ;;

			W) setArg browser-bin   "$OPTARG" ;;
			S) setArg server-type   "$OPTARG" ;;
			H) setArg server-host   "$OPTARG" ;;
			P) setArg server-port   "$OPTARG" ;;

			h) setArg help ;;

			_) setArg _ ;;  # hidden debug argument (only short)

			*) # error
                if [[ "$OPTERR" != 1 || "${optspec:0:1}" == ":" ]]; then
					log error "ERROR: unknown argument '-$OPTARG'"
					exit 255
                fi ;;
		esac
	done
	shift $((OPTIND-1))

} #parseArguments()


#-------------------------------------------------------------------------------
# setArg
#
#   Sets both short and long arguments, in a centralize manner.
#
# argument: $1 : the common long name of the argument
# argument: $2 : (optional) the value of the argument
#     exit: 13 : unknown argument
#   parent: parseArguments
#
setArg() {
	declare argument="$1" value="$2"

	case "$argument" in

		# OPERATIONAL flags
		process-templates)
			_OPERATIONAL=true
			_ARG_OPTIONS[_DO_PROCESS_TEMPLATES]=true ;;
		process-resources)
		   _OPERATIONAL=true
		   _ARG_OPTIONS[_DO_PROCESS_RESOURCES]=true ;;
		process-all)
			_OPERATIONAL=true
			_ARG_OPTIONS[_DO_PROCESS_RESOURCES]=true
			_ARG_OPTIONS[_DO_PROCESS_TEMPLATES]=true ;;
		preview)
			_OPERATIONAL=true
			_ARG_OPTIONS[_DO_PREVIEW_IN_BROWSER]=true ;;
		new-config)
			_OPERATIONAL=true
			_DO_GENERATE_CONFIG_FILE=true
			_ARG_OPTIONS[_DO_GENERATE_CONFIG_FILE]=true ;;


		# OPTIONS flags

		# The options whose name starts with an underscore `_` can only be
		# set via script arguments; they are not read from any configuration.

		file-config)
			_CONFIG_FILE="$value"
			_ARG_OPTIONS[_CONFIG_FILE]="$value" ;;
		config)
			_CONFIG_STRING="$value"
			_ARG_OPTIONS[_CONFIG_STRING]="$value" ;;
		clear-log)
			_ARG_OPTIONS[_OPTION_LOG_CLEAR]=true ;;
		dont-delete-output)
			_ARG_OPTIONS[_OPTION_DELETE_DIR_OUTPUT]=false ;;

		# The next options can also be defined in configuration file, but
		# passing them as an argument to the script has a higher priority.

		dir-templates)
			_ARG_OPTIONS[DIR_TEMPLATES]="$value" ;;
		dir-resources)
			_ARG_OPTIONS[DIR_RESOURCES]="$value" ;;
		dir-output)
			_ARG_OPTIONS[DIR_OUTPUT]="$value" ;;
		dir-build)
			_ARG_OPTIONS[DIR_BUILD]="$value" ;;
		log-level)
			_ARG_OPTIONS[OPTION_LOG_LEVEL]="$value" ;;
		log-file)
			_ARG_OPTIONS[LOG_FILE]="$value" ;;
		browser-bin)
			_ARG_OPTIONS[WEB_BROWSER]="$value" ;;
		server-type)
			_ARG_OPTIONS[SERVER_TYPE]="$value" ;;
		server-host)
			_ARG_OPTIONS[SERVER_HOST]="$value" ;;
		server-port)
			_ARG_OPTIONS[SERVER_PORT]="$value" ;;
		help)
			_DO_USAGE=true ;;
		version)
			versionInfo ;;
		_)
			__DO_PRINT_VARS=true ;;
		*)
			log error "ERROR: unknow argument '$argument'"
			exit 13 ;; # TODO unify with previous...
	esac

} #setArg()

#-------------------------------------------------------------------------------
# setupLog
#
#   Prepares the log file and writes all the logs previously saved in _PRELOG.
#
# parent: main
#
setupLog() {
	local parsedPrelog

	if [[ "$_OPTION_LOG_CLEAR" == true ]]; then
		log 3 warn "\nWarning: deleting previous log file '$LOG_FILE'"
		rm -- "$LOG_FILE" 2>/dev/null;
	fi

	# Write the pre-saved log to the file
	#
	# 1. filter out the lines with greater than current log level
	# 2. leave only the log message, discard the rest.
	# 3. bring back the newlines
	# 4. put the log level in the date header
	#
	# shellcheck disable=SC2059
	parsedPrelog=$(printf "$_PRELOG" \
		| $__AWK -v logLevel=$OPTION_LOG_LEVEL -F '|' '$1<=logLevel' \
		| cut -d'|' -f3- \
		| tr '\a' '\n' \
		| $__SED "s/====@$/====$OPTION_LOG_LEVEL/" \
	)
	_PRELOG=false

	[[ -n "$parsedPrelog" ]] && log "$parsedPrelog"

} #setupLog()


#-------------------------------------------------------------------------------
# log
#
#   prints a message to the log file. Errors and warnings also to STDERR.
#
# argument: $1  : (optional) logLevelNeeded
# argument: $2  : (optional) logType [warn|error]
# argument: $3+ : log message
#   parent: <almost all functions>
#
# shellcheck disable=SC2059
log() {
	declare logLevelNeeded="$1" # First (optional) parameter
	declare -ir logLevelMin=1 logLevelMax=3
	declare logLevel

	declare logMessage msg_1line

	# must be an integer number
	if [[ "$logLevelNeeded" =~ ^[0-9]+$ ]]; then
		if [[ "$logLevelNeeded" -lt "$logLevelMin" ]]; then
			logLevel="$logLevelMin"
		elif [[ "$logLevelNeeded" -gt "$logLevelMax" ]]; then
			logLevel="$logLevelMax"
		else
			logLevel="$logLevelNeeded"
		fi
		shift # prepare next positional parameter

	else # if not a number, use defaults
		logLevel="$logLevelMin"
	fi

	local logType="$1" # Second (optional) parameter

	# must be the type
	case "$logType" in
		error|warn)
			shift # prepare next positional parameter
			;;
		*) logType="" ;;
	esac

	local IFSbkp="$IFS"; IFS=$''
	logMessage="$*" # All that remains is the log message
	IFS="$IFSbkp"

	if [[ "$_PRELOG" == false ]]; then
		if [[ "$logLevel" -le "$OPTION_LOG_LEVEL" ]]; then
			printf "$logMessage\n" >> "$LOG_FILE"
		fi
	else
		# Pre-save this log message as a single line
		#
		# 1. replace the newlines with a BEL
		# 2. put the log level and type at the beginning
		msg_1line=$(printf "$logMessage" | tr '\n' '\a') || true
		_PRELOG+="\n$logLevel|$logType|$msg_1line"
	fi

	# Print errors and warnings to stderr
	if [[ "$logType" == "error" || "$logType" == "warn" ]]; then
		printf "$logMessage" | tr -d '\n' | $__AWK '{ print }' - >&2 # [OPTIMIZE]
	fi

} #log()


#-------------------------------------------------------------------------------
# previewWebsite
#
#   Prepares the server commands, for previewing in the browser.
#
#   exit: 5 : Server type not recognized
# parent: main : when the script received the `-r` flag
#
previewWebsite() {
	local cmdBrowser

	# shellcheck disable=SC2016
	case "$SERVER_TYPE" in
		python)
			SERVER_START='pushd "$DIR_OUTPUT"; python -m SimpleHTTPServer $SERVER_PORT'
			SERVER_STOP='kill $(pgrep -f "python -m SimpleHTTPServer")'
			;;
		php)
			SERVER_START='php -S "$SERVER_HOST:$SERVER_PORT" -t "$DIR_OUTPUT"'
			SERVER_STOP='kill $(pgrep -f "php -S $SERVER_HOST")'
			;;
		none) # useful when not using `dir/index.html` structure
			SERVER_START=""
			SERVER_STOP=""
			;;
		custom) # for when a server is already running, or custom SERVER_START
			;;
		*)
			log 2 error "ERROR: Not recognized SERVER_TYPE='$SERVER_TYPE'"
			exit 5
			;;
	esac

	printf 'Loading website in "%s"...\n' "$WEB_BROWSER"

	if [[ "$SERVER_TYPE" == "none" ]]; then
		cmdBrowser="$WEB_BROWSER file://$($__READLINK -f $DIR_OUTPUT) &"
	else
		cmdBrowser="$WEB_BROWSER http://$SERVER_HOST:$SERVER_PORT &"
	fi

	sleep 1s && eval "$cmdBrowser" >&2 2>/dev/null
	if [[ -n "$SERVER_START" ]]; then
		printf '(Use CTRL+C to stop the "%s" web server)\n' \
			"$SERVER_TYPE"
		printf 'SERVER_START=%s' "$SERVER_START"
		eval "$SERVER_STOP >&2 2>/dev/null"; eval "$SERVER_START"
	fi

} #previewWebsite()


#-------------------------------------------------------------------------------
# deleteDirectories
#
#   Deletes the build/ and output directories if there's going to be operations.
#
# parent: main
#
deleteDirectories() {
	[[ "$OPTION_DELETE_DIR_BUILD" == true ]] && rm -rf -- "$DIR_BUILD" 2>/dev/null

	if [[ "$_OPTION_DELETE_DIR_OUTPUT" == true ]] && \
		[[ $_DO_PROCESS_RESOURCES == true \
		|| $_DO_PROCESS_TEMPLATES == true ]]; then
		rm -rf -- "$DIR_OUTPUT" 2>/dev/null
	fi

} #deleteDirectories()


#-------------------------------------------------------------------------------
# readConfig
#
#   Reads some configuration from a file or a string,
#   and joins it together to a common source.
#
# argument: $1 : $configType [file|string]
# argument: $2 : $configPointer can be either the file name or the variable name
#     exit: 10 : unknown config type
#   parent: main
#
readConfig() {
	declare configType="$1" configPointer="$2"
	declare readConfig configLine

	if [[ "$configType" == "string" ]]; then
		if [[ -n "${!configPointer}" ]]; then # string is not empty
			log 3 "Reading settings passed as an argument."
			readConfig="$(printf '%s' "${!configPointer}" \
				| $__SED -e "$_SED_TRIM_WS" \
				| $__SED -e "$_SED_DEL_COMMENTS" -e "$_SED_DEL_EMPTYLINES" \
				| $__SED -e "$_SED_JOIN_SPLITLINES" \
			)"$'\n'
			_CONFIG_JOINT+="$readConfig"
			__varsPush strn "" "$readConfig"
		fi

	elif [[ "$configType" == "file" ]]; then
		if [[ -f "$configPointer" ]]; then # file exists

			if [[ "$_DO_GENERATE_CONFIG_FILE" == true ]]; then
				log 2 warn "Warning: automatic override of an existing " \
					"local config file ('$configPointer') is not permitted."
			else
				log 3 "Reading settings from file '$configPointer'"
				readConfig="$(sed -e "$_SED_TRIM_WS" "$configPointer" \
					| $__SED -e "$_SED_DEL_COMMENTS" -e "$_SED_DEL_EMPTYLINES" \
					| $__SED -e "$_SED_JOIN_SPLITLINES" \
				)"$'\n'
				_CONFIG_JOINT+="$readConfig" # append
				__varsPush file "$configPointer" "$readConfig"
			fi

		else # config file doesn't exist
			# it's the config file of the project
			if [[ "$configPointer" == "$_CONFIG_FILE" ]]; then
				 # stop if printing debug info
				[[ "$__DO_PRINT_VARS" == true ]] && return 0

				if [[ "$_DO_GENERATE_CONFIG_FILE" == true ]]; then
					generateConfig
				else
					log 3 warn "Warning: project's config file " \
						"'$_CONFIG_FILE' doesn't exist."
				fi
			fi
		fi
	else
		log error "Error: unknown config type"
		exit 10
	fi

} #readConfig()


#-------------------------------------------------------------------------------
# configureSettings
#
#   Parses the configuration settings and overrides them with:
#   1) the joint configuration 2) the passed arguments.
#
#   exit: 1 : (via usage) no main operatives flags used
# parent: main
#
configureSettings() {
	declare settingsList setting arg settingName settingValue settingPrevious

	settingsList="$(printf '%s' "$_CONFIG_JOINT" | $__GREP "^$_WS*config$_WS*:" )"

	if [[ -n "$settingsList" ]]; then
		log 1 "\nConfiguring settings...\n$_HEADING"

		local IFSbkp="$IFS"; IFS=$'\n'
		for setting in $settingsList; do
			settingName=$(printf '%s' "$setting" \
				| cut -d':' -f2 \
				| $__SED -e "$_SED_TRIM_WS")
			settingValue=$(printf '%s' "$setting" \
				| cut -d':' -f3- \
				| $__SED -e "$_SED_TRIM_WS")

			[[ -n "${!settingName}" ]] &&
				settingPrevious="(previous=${!settingName})"
			log 1 "${_IN}setting: $settingName=$settingValue " \
				"$settingPrevious"

			[[ "$setting" != _* ]] && # read (only public) settings from file
				printf -v "$settingName" '%s' "$settingValue"
		done
		IFS="$IFSbkp"
	fi

	# Override the settings with the parsed arguments
	for arg in "${!_ARG_OPTIONS[@]}"; do
		printf -v "$arg" '%s' "${_ARG_OPTIONS[$arg]}"
		printf -v __VARS_WEBERA '%s' \
			"$__VARS_WEBERA"$'\n'"[args]::$arg=${_ARG_OPTIONS[$arg]}"
	done

} #configureSettings()


#-------------------------------------------------------------------------------
# generateConfig
#
#   Generates a config file, writing down the settings modified via arguments.
#
# parent: main : when the script received the `-n` flag
#
generateConfig() {
	local configLines=()
	declare opt line

	for opt in "${!_ARG_OPTIONS[@]}"; do
		[[ "$opt" != _* ]] && # write (only public) vars to config file
			configLines+=("config : $opt : ${_ARG_OPTIONS[$opt]}")
	done

	touch "$_CONFIG_FILE"
	for line in "${configLines[@]}"; do
		printf '%s\n' "$line" >> "$_CONFIG_FILE"
	done

} #generateConfig()


#-------------------------------------------------------------------------------
# readConfigCommands
#
#   Reads the configuration commands for processing templates and resources.
#
# parent: main
#
readConfigCommands() {
	declare commandList cmd commandNum commandName commandAction

	commandList="$(printf '%s' "$_CONFIG_JOINT" | $__GREP "^$_WS*command$_WS*:" )"

	if [[ -n "$commandList" ]]; then
		commandNum=$(printf '%s\n' "$commandList" | wc -l )
		log 1 "\nParsing commands...\n$_HEADING"
		log 1 "${_IN}Found $commandNum defined command:"
	else return 0; fi

	local IFSbkp="$IFS"; IFS=$'\n'
	for cmd in $commandList; do # [OPTIMIZE]
		commandName=$(printf '%s' "$cmd" \
			| cut -d':' -f2 \
			| $__SED -e "$_SED_TRIM_WS" )
		commandAction=$(printf '%s' "$cmd" \
			| cut -d':' -f3- \
			| $__SED -e "$_SED_TRIM_WS" )

		_DEFINED_CMD_MAP["$commandName"]="$commandAction"

		log 2 "${_IN}$commandName='$commandAction'"
	done
	IFS="$IFSbkp"

} #readConfigCommands()


#-------------------------------------------------------------------------------
# processResources
#
#   Parses the configuration and executes the resource operations.
#
# return:    8 : no resources directory found
# parent: main : when the script received the `-r` flag
#
processResources() {
	declare resourceOpList resourceOpNum resourceOp
	declare operation fileOrigin fileTarget command

	log 1 "\nProcessing resources...\n$_HEADING"

	if [[ ! -d "$DIR_RESOURCES" ]]; then
		log 1 error "No resources dir '$DIR_RESOURCES' found."
		return 8
	fi

	resourceOpList="$(printf '%s' "$_CONFIG_JOINT" \
		| $__GREP "^$_WS*resource$_WS*:" )"
	resourceOpNum=$(printf '%s\n' "$resourceOpList" \
		| $__SED "$_SED_DEL_EMPTYLINES" \
		| wc -l )
	log 1 "${_IN}Found $resourceOpNum operations on resources:"

	local IFSbkp="$IFS"; IFS=$'\n'
	for resourceOp in $resourceOpList; do # [OPTIMIZE]
		operation=$(printf '%s' "$resourceOp" \
			| cut -d':' -f2 \
			| $__SED -e "$_SED_TRIM_WS" )
		fileOrigin=$(printf '%s' "$resourceOp" \
			| cut -d':' -f3 \
			| $__SED -e "$_SED_TRIM_WS" )
		fileTarget=$(printf '%s' "$resourceOp" \
			| cut -d':' -f4 \
			| $__SED -e "$_SED_TRIM_WS" )

		log 1 "${_IN}$operation: $fileOrigin > $fileTarget"

		if [[ ! -e "$DIR_RESOURCES/$fileOrigin" ]]; then
			log 1 error "${_IN}ERROR: '$fileOrigin' don't exist"
			continue # XXX do break instead?
		fi

		case "$operation" in
			"copy")
				mkdir -p -- "$DIR_OUTPUT/$DIR_RESOURCES/$(dirname "$fileTarget")"
				cp -r -- "$DIR_RESOURCES/$fileOrigin" \
					"$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget"
				;;
			*)
				# On custom commands, {PATHS} tags are adapted for resources
				if [[ -n "${_DEFINED_CMD_MAP[$operation]}" ]]; then

					command=$(printf '%s' "${_DEFINED_CMD_MAP[$operation]}" \
						| $__SED "s|{ORIGIN}|$DIR_RESOURCES/$fileOrigin|g" \
						| $__SED "s|{BUILD}|$DIR_BUILD/$fileOrigin|g" \
						| $__SED "s|{TARGET}|$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget|g")

					# Create target paths
					if [[ "${_DEFINED_CMD_MAP[$operation]}" == *"{BUILD}"* ]]; then
						mkdir -p -- "$(dirname "$DIR_BUILD/$fileTarget")"
					fi
					if [[ "${_DEFINED_CMD_MAP[$operation]}" == *"{TARGET}"* ]]; then
						mkdir -p -- "$(dirname \
							"$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget")"
					fi

					log 3 "${_IN}Executing: $command"
					eval "$command"
				else
					log 1 error \
						"${_IN}ERROR: operation '$operation' not recognized"
				fi
				;;
		esac
	done
	IFS="$IFSbkp"

} #processResources()


#-------------------------------------------------------------------------------
# processTemplates
#
#   Parses the configuration and executes the template operations.
#
# return:    9 : no templates directory found
# parent: main : when the script received the `-t` flag
#
processTemplates() {
	declare templateOpList templateOpNum templateOp
	declare operation fileOrigin fileTarget command

	log 1 "\nProcessing templates...\n$_HEADING"

	if [[ ! -d "$DIR_TEMPLATES" ]]; then
		log 1 error "No templates dir '$DIR_TEMPLATES' found."
		return 9
	fi

	templateOpList="$(printf '%s' "$_CONFIG_JOINT" \
		| $__GREP "^$_WS*template$_WS*:" )"

	templateOpNum=$(printf '%s\n' "$templateOpList" \
		| $__SED "$_SED_DEL_EMPTYLINES" \
		| wc -l )
	log 1 "${_IN}Found $templateOpNum operations on templates:"

	local IFSbkp="$IFS"; IFS=$'\n'
	for templateOp in $templateOpList; do
		operation=$(printf '%s' "$templateOp" \
			| cut -d':' -f2 \
			| $__SED -e "$_SED_TRIM_WS" )
		fileOrigin=$(printf '%s'  "$templateOp" \
			| cut -d':' -f3 \
			| $__SED -e "$_SED_TRIM_WS" )
		fileTarget=$(printf '%s' "$templateOp" \
			| cut -d':' -f4 \
			| $__SED -e "$_SED_TRIM_WS" )

		log 1 "${_IN}$operation: $fileOrigin > $fileTarget"

		case "$operation" in
			"route")
				if [[ -n "$fileOrigin" && -n "$fileTarget" ]]; then
					# A path ending in `/`, will be a dir_name/index.html
					if [[ "$fileTarget" == */ ]]; then
						mkdir -p -- "${DIR_OUTPUT}/${fileTarget}"
						templateRender "$fileOrigin" > \
							"${DIR_OUTPUT}/${fileTarget}/index.html"
					else
						mkdir -p -- "$(dirname "${DIR_OUTPUT}/${fileTarget}")"
						templateRender "$fileOrigin" > \
							"${DIR_OUTPUT}/${fileTarget}"
					fi
				else
					log 1 error "${_IN}ERROR: missing arguments for" \
						"'template:route' operation"
				fi
				;;

			*)
				# On custom commands, the {PATHS} tags are adapted for templates
				if [[ -n "${_DEFINED_CMD_MAP[$operation]}" ]]; then

					command=$(printf '%s' "${_DEFINED_CMD_MAP[$operation]}" \
						| $__SED "s|{ORIGIN}|$DIR_TEMPLATES/$fileOrigin|g" \
						| $__SED "s|{BUILD}|$DIR_BUILD/$fileOrigin|g" \
						| $__SED "s|{TARGET}|$DIR_OUTPUT/$fileTarget|g" \
					)

					# Create target paths
					if [[ "${_DEFINED_CMD_MAP[$operation]}" == *"{BUILD}"* ]]; then
						mkdir -p -- "$(dirname "$DIR_BUILD/$fileTarget")"
					fi
					if [[ "${_DEFINED_CMD_MAP[$operation]}" == *"{TARGET}"* ]]; then
						mkdir -p -- "$(dirname "$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget")"
					fi

					log 3 "${_IN}Executing: $command"
					eval "$command"
				else
					log 1 error \
						"${_IN}ERROR: operation '$operation' not recognized"
				fi
				;;
		esac
	done
	IFS="$IFSbkp"

} #processTemplates()


#-------------------------------------------------------------------------------
# templateParseIncludes
#
#   Recursively parses a template for include directives, and then
#   joins all the parts together in a single template.
#
# argument: $1 : templateFileName
#   return:  7 : No template found
#     exit:  3 : Maximum nesting level overflow
#   parent: templateRender
#
templateParseIncludes() {
	declare templateFileName=$1
	declare templateContent directive directives_include incFileName incFileContent

	((_NESTING_LEVEL++))
	if [[ "$_NESTING_LEVEL" -gt "$NESTING_MAX" ]]; then
		log 1 error "${_IN}ERROR: max nesting level ($NESTING_MAX)" \
			"reached for template $templateFileName"
		exit 3
	fi

	# Parse template
	local templateFile="${DIR_TEMPLATES}/$templateFileName"
	if [[ -f "$templateFile" ]]; then
		templateContent="$(<"$templateFile")"
	else
		log 1 error "${_IN}ERROR: No template found '$templateFile'"
		return 7
	fi
	directives_include=$($__GREP -Po "<!--$_WS*%include$_WS*:.*?-->" \
		"$templateFile") # [INC01]

	local IFSbkp="$IFS"; IFS=$'\n'

	# Remove duplicates
	if [[ -n "$directives_include" ]]; then
		directives_include=$(printf '%s' "$directives_include" | uniq)
	fi

	for directive in $directives_include; do
		incFileName=$(printf '%s' "$directive" \
			| $__SED -n -e "s/<\!--$_WS*%include$_WS*:$_WS*\(.*\)$_WS*-->/\1/p" \
			| $__SED -e "s/$_WS*$//" )
		log 2 "${_IN2}include: '$incFileName'"

		# Parse included template for further includes
		incFileContent="$(templateParseIncludes "${incFileName}")"

		# Mass-replace directive with template contents
		templateContent="${templateContent//$directive/$incFileContent}"
	done
	IFS="$IFSbkp"

	((_NESTING_LEVEL--))

	printf '%s' "$templateContent"

} #templateParseIncludes()


#-------------------------------------------------------------------------------
# templateRender
#
#   Parses the template, processes the directives and renders the html file.
#
# argument: $1 : templateFileName
#   parent: processTemplates (when parsing the 'route' command)
#
templateRender() {
	declare templateFileName=$1

	declare templateText directives_set directives_cmd directives_setcmd
	declare directive setVarVal setVar setValue cmd cmdOutput
	declare setCmdVar setCmdValue setCmd setCmdOutput
	declare -i cmdOutputLength maxOutputLength=50 # in characters

	templateText="$(templateParseIncludes "$templateFileName")"

	# Template tags must be one-liners
	directives_set=$(printf '%s' "$templateText" \
		| $__GREP -Po "<!--$_WS*%set$_WS*:.*?-->") # [INC01]
	directives_cmd=$(printf '%s' "$templateText" \
		| $__GREP -Po "<!--$_WS*%cmd$_WS*:.*?-->") # [INC01]
	directives_setcmd=$(printf '%s' "$templateText" \
		| $__GREP -Po "<!--$_WS*%setcmd$_WS*:.*?-->") # [INC01]

	# text comments
	#
	# <!-- // Comment -->
	#
	templateText=$(printf '%s' "$templateText" \
		| $__SED -e :a -re "s/<!--$_WS*\/\/.*?-->//g;/<!--\/\//N;//ba")

	local IFSbkp="$IFS"; IFS=$'\n'

	# set variables
	#
	# <!-- %set : VARIABLE=something -->
	# <!-- @VARIABLE -->
	#
	for directive in $directives_set; do
		setVarVal=$(printf '%s' "$directive" \
			| $__SED -n -e "s/<\!--$_WS*%set$_WS*:$_WS*\(.*\)$_WS*-->/\1/p"\
			| $__SED -e "s/$_WS*$//")
		setVar="${setVarVal%%=*}"
		setValue="${setVarVal#*=}"
		log 3 "${_IN3}set: $setVar = $setValue"

		# Cross-platform syntax to replace including newlines
		# http://stackoverflow.com/a/1252191
		templateText=$(printf '%s' "$templateText" \
			| $__SED -e ":a" -e "N" -e "\$!ba" -e "s/$directive\n\?//g")
		templateText=$(printf '%s' "$templateText" \
			| $__SED -e ":a" -e "N" -e "\$!ba" \
			-e "s/<!--$_WS*@$setVar$_WS*-->\n\?/$setValue/g")
	done

	# execute commands, render output
	#
	# <!-- %cmd : ls -l -->
	#
	for directive in $directives_cmd ; do
		cmd=$(printf '%s' "$directive" \
			| $__SED -n -e "s/^.*<\!--$_WS*%cmd$_WS*:$_WS*\(.*\)$_WS*-->.*$/\1/p" \
			| $__SED -e "s/$_WS*$//")
		cmdOutput=$(eval "$cmd")
		log 3 "${_IN2}cmd: $cmd"

		cmdOutputLength=$(printf "%s" "$cmdOutput" | wc -c)

		if [[ "$cmdOutputLength" -le "$maxOutputLength" ]]; then
			log 3 "${_IN3}=: $cmdOutput"
		else
			log 3 "${_IN3}=: $(printf '%s' "$cmdOutput" \
				| tr '\n' ' ' \
				| head -c$maxOutputLength) (...) +" \
				"$((cmdOutputLength-maxOutputLength)) chars"
		fi

		# Substitute the directive in the template with the command output
		# http://stackoverflow.com/a/40749641/940200
		templateText=$($__AWK -v repl="$cmdOutput" 'FNR==NR {
				a = a $0; next
			}
			n = index($0, a) {
				$0 = substr($0, 1, n-1) repl substr($0, n+length(a))
			} 1' <(printf '%s\n' "$directive") <(printf '%s' "$templateText")
		)
	done

	# set variables to commands output
	#
	# <!-- %setcmd : VARIABLE=ls -l -->
	# <!-- @VARIABLE -->
	#
	for directive in $directives_setcmd; do
		setCmd=$(printf '%s' "$directive" \
			| $__SED -n -e "s/^.*<\!--$_WS*%setcmd$_WS*:$_WS*\(.*\)$_WS*-->.*$/\1/p" \
			| $__SED -e "s/$_WS*$//")
		setCmdVar="${setCmd%%=*}"
		setCmdValue="${setCmd#*=}"
		setCmdOutput=$(eval "$setCmdValue")
		log 3 "${_IN2}setcmd: $setCmdVar = $setCmdValue"

		# Delete the directive from the template
		templateText=$($__AWK -v 'FNR==NR {
				a = a $0; next
			}
			n = index($0, a) {
				$0 = substr($0, 1, n-1) substr($0, n+length(a))
			} 1' <(printf '%s\n' "$directive") <(printf '%s' "$templateText")
		)
		# Replace all the set variables with the command output
		templateText=$(printf '%s' "$templateText" \
			| $__SED -e ":a" -e "N" -e "\$!ba" \
			-e "s/<!--$_WS*@$setCmdVar$_WS*-->\n\?/$setCmdOutput/g")
	done

	IFS="$IFSbkp"

	log 3

	printf "%s" "$templateText"

} #templateRender()


#-------------------------------------------------------------------------------
# __checkCompatibility
#
#   Checks for dependencies and displays pertinent information.
#
#   exit: 6 : Bash version is too old
# parent: main
#
__checkCompatibility() {

	# Bash version >= 4
	if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
		printf '%s\n' "Bash version >=4 needed. Current version is $BASH_VERSION"

		if [[ "$(uname)" == 'Darwin' ]]; then
			printf 'You can install it with Brew (http://brew.sh)\n like this:'
			printf 'brew install bash\n'
		fi
		exit 6
	fi

	# prefer the GNU version of the Unix commands used, specially in Mac OS X
	__SED="$(__gnuCmd sed)"
	__AWK="$(__gnuCmd  awk)"
	__GREP="$(__gnuCmd grep)"
	__DATE="$(__gnuCmd date)"
	__READLINK="$(__gnuCmd readlink)"

} #__checkCompatibility()


#-------------------------------------------------------------------------------
# __gnuCmd
#
#   Returns the resolved command, preferring the GNU versions
#   and falling back to the standard version when not found.
#
__gnuCmd() {
	local default_cmd="$1"
	local gnu_cmd="g$default_cmd"

	if [[ "$(which "$gnu_cmd" 2> /dev/null)" ]]; then
		printf '%s' "$gnu_cmd"
	else
		printf '%s' "$default_cmd"
	fi

} #__gnuCmd()


#-------------------------------------------------------------------------------
# __setupDebugging
#
#   Enables xtrace if WEBERA_DEBUG has been defined, and sets a nice formatting.
#
# parent: main
#
# shellcheck disable=SC2016
__setupDebugging() {
	local ps4_date='[$(($($__DATE "+%s%3N")-__WEBERA_TIME_STAMP))ms]' # [INC02]
	local ps4_line='L$LINENO'
	local ps4_func='${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

	[[ -n "$WEBERA_DEBUG" ]] && set -o xtrace && \
		export PS4="+ $ps4_date $ps4_line $ps4_func"

} #__setupDebugging()


#-------------------------------------------------------------------------------
# __varsPrint
#
#   Prints all the script "global" settings and data, public and private.
#
__varsPrint() { printf '%s\n' "$__VARS_WEBERA"; }


#-------------------------------------------------------------------------------
# __varsPush
#
#   Parses configuration, extracts the config variables and appends them
#   to __VARS_WEBERA in the correct format, using the provided arguments.
#
# argument: $1 : varOrigin [vdef|args|file|strn]
# argument: $2 : varPath (for files)
# argument: $3 : configuration
#   parent: readConfig
#
__varsPush() {
	declare varOrigin="$1" varPath="$2" configuration="$3"
	declare configLine

	local IFSbkp="$IFS"; IFS=$'\n'
	for configLine in $(printf '%s' "$configuration" \
		| $__GREP '^config' \
		| cut -d ':' -f2- \
		| $__SED "s/$_WS*:$_WS*/=/" \
		| $__SED "$_SED_TRIM_WS" \
		); do
		if [[ "$configLine" != _* ]]; then # only read public variables
			printf -v __VARS_WEBERA '%s' \
			"$__VARS_WEBERA"$'\n'"[$varOrigin]:$varPath:$configLine"
		fi
	done
	IFS="$IFSbkp"

} #__varsPush()


#-------------------------------------------------------------------------------
# __timeReport
#
#   Prints the spent time on the script, in milliseconds.
#
# argument: $1 : when true, prints the time beautified
#
__timeElapsed() {
	local beautiful="$1"
	local -ir timeStampFinal="$($__DATE '+%s%3N')"
	local -ir timeElapsed="$((timeStampFinal-__WEBERA_TIME_STAMP))"
	if [[ "$beautiful" == true ]]; then
		printf '%s' "$(__timeBeautify "$timeElapsed")"
	else
		printf '%s' "$timeElapsed"
	fi

} #__timeElapsed()


#-------------------------------------------------------------------------------
# __timeBeautify
#
#   Tries to format a time in milliseconds into a human readable text string
#   showing the days, hours, minutes and/or seconds contained in that time.
#
# argument: $1 : time in milliseconds
#
__timeBeautify() {
	local -ir ms="$1"
	local -ir s="$((ms/1000%60))"
	local -ir m="$((ms/60000%60))"
	local -ir h="$((ms/3600000%24))"
	local -ir d="$((ms/86400000))"

	declare timeString didTime

	[[ "$d" -gt 0 ]] && timeString+="${d}d " && didTime=true
	[[ "$h" -gt 0 || -n "$didTime" ]] && timeString+="${h}h " && didTime=true
	[[ "$m" -gt 0 || -n "$didTime" ]] && timeString+="${m}m " && didTime=true
	[[ -n "$didTime" ]] && timeString+="${s}s " # shows seconds if time > 1m
	[[ "$m" -lt 1 && -z "$didTime" ]] && timeString+="${ms}ms "

	printf '%s' "${timeString}"

} #__timeBeautify()


[[ "$0" == "${BASH_SOURCE[0]}" ]] && main "$@" # Run if not sourced
