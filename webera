#!/usr/bin/env bash
# shellcheck disable=SC2016
#
#         name : webera
#  description : a handy static website generator
#   repository : https://github.com/andamira/webera
#       author : José Luis Cruz © 2016-2017
#      license : MIT
_WEBERA_VERSION=0.1.66


#-------------------------------------------------------------------------------
# ::main
#
# argument: $@ : all the arguments passed to the script
#
webera::main() {

	## PRE-SETUP

	# Binaries found for Unix commands employed
	declare __SED __AWK __GREP __DATE __READLINK

	webera::check-compatibility
	local -ir __WEBERA_TIME_STAMP="$($__DATE '+%s%3N')" # [INC02]
	webera::setup-debugging

	# prepare to save a list of the default settings
	declare __VARS_WEBERA __VARS_BEFORE __VARS_AFTER
	__VARS_BEFORE=$(set -o posix ; set | $__AWK -F= '{print $1"="}' )


	## CONFIGURABLE SETTINGS
	#
	# NOTE-1: Variables starting with an underscore can't be configured
	# from a file|string, but they can be set using script arguments.
	# NOTE-2: Variables that don't have an argument associated they
	# can only be changed via config file|string.

	# statuses
	local _OPERATIONAL=false              # -trawn
	local _DO_PROCESS_TEMPLATES=false     # -ta
	local _DO_PROCESS_RESOURCES=false     # -ra
	local _DO_PREVIEW_IN_BROWSER=false    # -w
	local _DO_GENERATE_CONFIG_FILE=false  # -n

	# Paths
	local DIR_TEMPLATES=tem               # -T
	local DIR_RESOURCES=res               # -R
	local DIR_OUTPUT=out                  # -O
	local DIR_BUILD=build                 # -B
	local _CONFIG_FILE=.weberarc          # -F
	local _CONFIG_STRING=''               # -S

	# Delete output & build directories
	local _DO_DELETE_DIR_OUTPUT=true      # -d
	local DO_DELETE_DIR_BUILD=true

	# Log
	local LOG_FILE=log.txt                # -G
	local _DO_CLEAR_LOG=false             # -c
	local -i LOG_LEVEL=0                  # -L [0-3]

	# Web Browser
	local WEB_BROWSER="firefox"           # -W
	local SERVER_TYPE="python"            # -S
	local SERVER_HOST="localhost"         # -H
	local -i SERVER_PORT=8192             # -P
	local SERVER_START=""
	local SERVER_STOP=""

	# Misc
	local _DO_DISPLAY_USAGE=false         # -h
	local _DO_PRINT_VARS=false            # -_
	local -i NESTING_MAX=8


	## NON-CONFIGURABLE DATA

	# arrays
	declare -A _ARG_OPTIONS
	declare -A _DEFINED_CMD_MAP

	local -i _NESTING_LEVEL=0

	local _CONFIG_JOINT="" # where to save all the configurations
	local _PRELOG="" # where log is saved before there's a logfile

	local -r _DATE_START="$($__DATE '+%Y-%m-%d %H:%M:%S' \
		-d @"${__WEBERA_TIME_STAMP:0:10}")" # [INC03]


	## POST-SETUP

	# save the list of the default settings
	__VARS_AFTER="$(set -o posix ; set | $__SED '/^'\''/d' )"
	printf -v __VARS_WEBERA '%s' "$($__GREP -vFf \
		<(printf '%s' "$__VARS_BEFORE") <(printf '%s' "$__VARS_AFTER") \
		| $__SED 's/^/[vdef]::/' )"
	unset __VARS_BEFORE; unset __VARS_AFTER;


	## STRING CONSTANTS

	# whitespace indentation and headline
	declare -r _IN="  " _IN2="    " _IN3="      "
	local -r _HL='------------------------------------------------------'

	# reusable regexp patterns
	local -r _WS="[[:space:]]" # whitespace
	local -r _SED_TRIM_WS="s/^$_WS*//;s/$_WS*$//"
	local -r _SED_DEL_COMMENTS="/^$_WS*#.*/d" # starting in #
	local -r _SED_DEL_EMPTYLINES="/^$_WS*$/d"
	local -r _SED_JOIN_SPLITLINES=':x; /\\$/ {N; s/\\\n//; tx}' # ending in \


	## webera::main LOGIC

	webera::log "\n===============[$_DATE_START]==============@\n" # s/@$/LOG_LEVEL/

	webera::parse-arguments "$@"

	# Read the configuration files & string
	[[ "$_CONFIG_FILE" != "/etc/weberarc" ]] && webera::read-config file "/etc/weberarc"
	[[ "$_CONFIG_FILE" != "$HOME/.weberarc" ]] && webera::read-config file "$HOME/.weberarc"
	webera::read-config file "$_CONFIG_FILE"
	webera::read-config string '_CONFIG_STRING'

	webera::configure-settings

	if [[ "$_DO_PRINT_VARS" == true ]]; then
		webera::print-vars; exit 0
	elif [[ "$_DO_DISPLAY_USAGE" == true || "$_OPERATIONAL" == false ]]; then
		webera::display-usage
	fi

	webera::setup-log

	[[ "$_OPERATIONAL" == false ]] && exit 1

	webera::delete-directories

	webera::read-config-commands

	[[ "$_DO_PROCESS_RESOURCES" == true ]] && webera::process-resources
	[[ "$_DO_PROCESS_TEMPLATES" == true ]] && webera::process-templates

	webera::log "Total elapsed time: $(webera::elapsed-time true)"

	[[ "$_DO_PREVIEW_IN_BROWSER" == true ]] && webera::preview-website
	exit 0

} #::main()


#-------------------------------------------------------------------------------
# ::display-usage
#
#   Displays usage information.
#
#   parent: webera::parse-arguments webera::configure-settings
#
webera::display-usage() {

	cat -- <<-ENDUSAGE
	Usage: $(basename "$0") -[trawn] [other options]

	> a handy static website generator <

	INSTRUCTIONS

	1. At least one OPERATIVE FLAG is needed in order for the script to run.
	2. Mandatory arguments to long options, are mandatory for short options too.

	OPERATIVE FLAGS              ...

	  -t, --process-templates    process the templates
	  -r, --process-resources    process the resources
	  -a, --process-all          process both the templates and the resources
	  -w  --preview              preview website in the web browser
	  -n  --new-config           generate a new configuration file

	OPTION FLAGS                 ... (default value)

	  -F, --file-config=FILE     indicate the configuration file ($_CONFIG_FILE)
	  -C, --config=STRING        pass the configuration as a string ($_CONFIG_STRING)

	  -T, --dir-templates=DIR    indicate the templates directory ($DIR_TEMPLATES)
	  -R, --dir-resources=DIR    indicate the resources directory ($DIR_RESOURCES)
	  -O, --dir-output=DIR       indicate the output directory ($DIR_OUTPUT)
	  -B, --dir-build=DIR        indicate the build directory ($DIR_BUILD)
	  -d, --dont-delete-output   don't delete the output dir ($_DO_DELETE_DIR_OUTPUT)

	  -L, --log-level=LEVEL      log level [0=none|1|2|3] ($LOG_LEVEL)
	  -c, --clear-log            clear the previous log file ($_DO_CLEAR_LOG)
	  -G, --logfile=FILE         log file ($LOG_FILE)

	  -W, --browser-bin=BIN      web browser binary ($WEB_BROWSER)
	  -S, --server-type=TYPE     server type [none|php|python|custom] ($SERVER_TYPE)
	  -H, --server-host=HOST     server host ($SERVER_HOST)
	  -P, --server-port=PORT     port number ($SERVER_PORT)

	  -h, --help                 display this help and exit
	      --version              show version info and exit

	ENDUSAGE

} #::display-usage()


#-------------------------------------------------------------------------------
# ::display-version
#
#   Displays version information and exits.
#
# argument: $1 : (optional) error code
#     exit: $1 : same received error code
#   parent: webera::parse-arguments webera::configure-settings
#
webera::display-version() {

	cat -- <<-ENDVERSION
	webera v$_WEBERA_VERSION

	<https://github.com/andamira/webera>

	Copyright (C) 2016-2017 José Luis Cruz
	Released under the MIT license.

	Dependencies found:
	  $__SED, $__AWK, $__GREP, $__DATE
	ENDVERSION
	exit 0

} #::display-version()


#-------------------------------------------------------------------------------
# ::parse-arguments
#
#  Parses the arguments received by the script and sets/saves the options.
#
# argument:   $@ : all the arguments passed to the script
#   parent: webera::main
#
webera::parse-arguments() {

	local OPTIND option value
	local optspec=':trawnF:C:T:R:O:B:dcL:G:W:S:H:P:_h-:'

	while getopts "$optspec" option; do
		case "$option" in

			# long option flags: http://stackoverflow.com/a/7680682/940200
			-)
				case "$OPTARG" in

					process-templates) webera::set-arg process-templates   ;;
					process-resources) webera::set-arg process-resources   ;;
					process-all)       webera::set-arg process-all         ;;
					preview)           webera::set-arg preview             ;;
					new-config)        webera::set-arg new-config          ;;

					file-config=*)
						webera::set-arg file-config   "${OPTARG#*=}" ;;
					config=*)
						webera::set-arg config        "${OPTARG#*=}" ;;
					dir-templates=*)
						webera::set-arg dir-templates "${OPTARG#*=}" ;;
					dir-resources=*)
						webera::set-arg dir-resources "${OPTARG#*=}" ;;
					dir-output=*)
						webera::set-arg dir-output    "${OPTARG#*=}" ;;
					dir-build=*)
						webera::set-arg dir-build     "${OPTARG#*=}" ;;

					dont-delete-output) webera::set-arg dont-delete-output ;;
					clear-log)          webera::set-arg clear-log          ;;

					log-level=*)
						webera::set-arg log-level     "${OPTARG#*=}" ;;
					log-file=*)
						webera::set-arg log-file      "${OPTARG#*=}" ;;

					browser-bin=*)
						webera::set-arg browser-bin   "${OPTARG#*=}" ;;
					server-type=*)
						webera::set-arg server-type   "${OPTARG#*=}" ;;
					server-host=*)
						webera::set-arg server-host   "${OPTARG#*=}" ;;
					server-port=*)
						webera::set-arg server-port   "${OPTARG#*=}" ;;

					help) webera::set-arg help ;;
					version) webera::set-arg version ;;

					*) [[ "$OPTERR" == 1 ]] && webera::set-arg "--$OPTARG" ;;
				esac ;;

			# short option flags

			t) webera::set-arg process-templates       ;;
			r) webera::set-arg process-resources       ;;
			a) webera::set-arg process-all             ;;
			w) webera::set-arg preview                 ;;
			n) webera::set-arg new-config              ;;

			F) webera::set-arg file-config   "$OPTARG" ;;
			C) webera::set-arg config        "$OPTARG" ;;

			T) webera::set-arg dir-templates "$OPTARG" ;;
			R) webera::set-arg dir-resources "$OPTARG" ;;
			O) webera::set-arg dir-output    "$OPTARG" ;;
			B) webera::set-arg dir-build     "$OPTARG" ;;

			d) webera::set-arg dont-delete-output      ;;
			c) webera::set-arg clear-log               ;;

			L) webera::set-arg log-level     "$OPTARG" ;;
			G) webera::set-arg log-file      "$OPTARG" ;;

			W) webera::set-arg browser-bin   "$OPTARG" ;;
			S) webera::set-arg server-type   "$OPTARG" ;;
			H) webera::set-arg server-host   "$OPTARG" ;;
			P) webera::set-arg server-port   "$OPTARG" ;;

			h) webera::set-arg help ;;

			_) webera::set-arg _ ;;  # hidden debug argument (only short)

			*) [[ "$OPTERR" != 1 || "${optspec:0:1}" == ":" ]] &&
				webera::set-arg "-$OPTARG" ;;
		esac
	done
	shift $((OPTIND-1))

} #::parse-arguments()


#-------------------------------------------------------------------------------
# ::set-arg
#
#   Sets both short and long arguments, in a centralize manner.
#
# argument:  $1 : the common long name of the argument
# argument:  $2 : (optional) the value of the argument
#     exit: 255 : unknown argument
#   parent: webera::parse-arguments
#
webera::set-arg() {

	declare argument="$1" value="$2"

	case "$argument" in

		# OPERATIONAL flags
		process-templates)
			_OPERATIONAL=true
			_ARG_OPTIONS[_DO_PROCESS_TEMPLATES]=true    ;;
		process-resources)
		   _OPERATIONAL=true
		   _ARG_OPTIONS[_DO_PROCESS_RESOURCES]=true     ;;
		process-all)
			_OPERATIONAL=true
			_ARG_OPTIONS[_DO_PROCESS_RESOURCES]=true
			_ARG_OPTIONS[_DO_PROCESS_TEMPLATES]=true    ;;
		preview)
			_OPERATIONAL=true
			_ARG_OPTIONS[_DO_PREVIEW_IN_BROWSER]=true   ;;
		new-config)
			_OPERATIONAL=true
			_DO_GENERATE_CONFIG_FILE=true
			_ARG_OPTIONS[_DO_GENERATE_CONFIG_FILE]=true ;;


		# OPTIONS flags

		# Options whose name starts with an underscore `_` can only be set
		# via script arguments; they are not read from any configuration.

		file-config)
			_CONFIG_FILE="$value"
			_ARG_OPTIONS[_CONFIG_FILE]="$value"        ;;
		config)
			_CONFIG_STRING="$value"
			_ARG_OPTIONS[_CONFIG_STRING]="$value"      ;;
		clear-log)
			_ARG_OPTIONS[_DO_CLEAR_LOG]=true           ;;
		dont-delete-output)
			_ARG_OPTIONS[_DO_DELETE_DIR_OUTPUT]=false  ;;

		# The following options can also be defined in configuration file,
		# but passing them as arguments to the script has a higher priority.

		dir-templates)
			_ARG_OPTIONS[DIR_TEMPLATES]="$value"       ;;
		dir-resources)
			_ARG_OPTIONS[DIR_RESOURCES]="$value"       ;;
		dir-output)
			_ARG_OPTIONS[DIR_OUTPUT]="$value"          ;;
		dir-build)
			_ARG_OPTIONS[DIR_BUILD]="$value"           ;;
		log-level)
			_ARG_OPTIONS[LOG_LEVEL]="$value"           ;;
		log-file)
			_ARG_OPTIONS[LOG_FILE]="$value"            ;;
		browser-bin)
			_ARG_OPTIONS[WEB_BROWSER]="$value"         ;;
		server-type)
			_ARG_OPTIONS[SERVER_TYPE]="$value"         ;;
		server-host)
			_ARG_OPTIONS[SERVER_HOST]="$value"         ;;
		server-port)
			_ARG_OPTIONS[SERVER_PORT]="$value"         ;;
		help)
			_DO_DISPLAY_USAGE=true ;;
		version)
			webera::display-version ;;
		_)
			_DO_PRINT_VARS=true ;;
		*) # UNKNOWN
			webera::log error "ERROR: unknow argument '$argument'"
			exit 255 ;; # TODO send to log
	esac

} #::set-arg()


#-------------------------------------------------------------------------------
# ::setup-log
#
#   Prepares the log file and writes all the logs previously saved in _PRELOG.
#
# parent: webera::main
#
webera::setup-log() {

	local parsedPrelog

	if [[ "$_DO_CLEAR_LOG" == true ]]; then
		webera::log 3 warn "\nWarning: deleting previous log file '$LOG_FILE'"
		rm -- "$LOG_FILE" 2>/dev/null;
	fi

	# Restore the pre-saved log messages
	#
	# 1. filter out the lines with greater than current log level
	# 2. leave only the log message, discard the rest. TODO: restore warn|error
	# 3. bring back the newlines previously converted to BEL.
	# 4. put the log level in the date header
	#
	# shellcheck disable=SC2059
	parsedPrelog=$(printf "$_PRELOG" \
		| $__AWK -v logLevel=$LOG_LEVEL -F '|' '$1<=logLevel' \
		| cut -d'|' -f3- \
		| tr '\a' '\n' \
		| $__SED "s/====@$/====$LOG_LEVEL/" \
	)
	_PRELOG=false

	[[ -n "$parsedPrelog" ]] && webera::log "$parsedPrelog" # print what's left

} #::setup-log()


#-------------------------------------------------------------------------------
# ::log
#
#   Prints a message to the log file. Errors and warnings also to STDERR.
#
# argument: $1  : (optional) logLevelNeeded
# argument: $2  : (optional) logType [warn|error]
# argument: $3+ : log message
#   parent: <almost all functions>
#
# shellcheck disable=SC2059
webera::log() {

	declare logLevelNeeded="$1" # First (optional) parameter
	declare -ir logLevelMin=1 logLevelMax=3
	declare logLevel

	# must be an integer number
	if [[ "$logLevelNeeded" =~ ^[0-9]+$ ]]; then
		if [[ "$logLevelNeeded" -lt "$logLevelMin" ]]; then
			logLevel="$logLevelMin"
		elif [[ "$logLevelNeeded" -gt "$logLevelMax" ]]; then
			logLevel="$logLevelMax"
		else
			logLevel="$logLevelNeeded"
		fi
		shift # prepare next positional parameter

	else # if not a number, use defaults
		logLevel="$logLevelMin"
	fi

	local logType="$1" # Second (optional) parameter

	# must be the type
	case "$logType" in
		error|warn)
			shift # prepare next positional parameter
			;;
		*) logType="" ;;
	esac

	local IFSbkp="$IFS"; IFS=$''
	local logMessage="$*" # All that rewebera::mains is the log message
	IFS="$IFSbkp"

	if [[ "$_PRELOG" == false ]]; then
		if [[ "$logLevel" -le "$LOG_LEVEL" ]]; then
			printf "$logMessage\n" >> "$LOG_FILE"
		fi
	else
		# Pre-save this log message as a single line
		#
		# 1. replace the newlines with a BEL
		# 2. put the log level and type at the beginning
		local msg1line; msg1line=$(printf "$logMessage" | tr '\n' '\a') || true
		_PRELOG+="\n$logLevel|$logType|$msg1line"
	fi

	# Print errors and warnings to stderr [OPTIMIZE]
	if [[ "$logType" == "error" || "$logType" == "warn" ]]; then
		# 1. trim whitespace
		# 2. delete newlines
		# 3. print to STDERR
		printf "$logMessage" \
			| $__SED -e "$_SED_TRIM_WS" \
			| tr -d '\n' \
			| $__AWK '{ print }' - >&2
	fi

} #::log()


#-------------------------------------------------------------------------------
# ::preview-website
#
#   Prepares the server commands, for previewing in the browser.
#
#   exit: 5 : Server type not recognized
# parent: webera::main : when the script received the `-r` flag
#
webera::preview-website() {

	local cmdBrowser

	# shellcheck disable=SC2016
	case "$SERVER_TYPE" in
		python)
			SERVER_START='pushd "$DIR_OUTPUT"; python -m SimpleHTTPServer $SERVER_PORT'
			SERVER_STOP='kill $(pgrep -f "python -m SimpleHTTPServer")'
			;;
		php)
			SERVER_START='php -S "$SERVER_HOST:$SERVER_PORT" -t "$DIR_OUTPUT"'
			SERVER_STOP='kill $(pgrep -f "php -S $SERVER_HOST")'
			;;
		none) # useful when not using `dir/index.html` structure
			SERVER_START=""
			SERVER_STOP=""
			;;
		custom) # for when a server is already running, or custom SERVER_START
			;;
		*)
			webera::log 2 error "ERROR: Not recognized SERVER_TYPE='$SERVER_TYPE'"
			exit 5
			;;
	esac

	printf 'Loading website in "%s"...\n' "$WEB_BROWSER"

	if [[ "$SERVER_TYPE" == "none" ]]; then
		cmdBrowser="$WEB_BROWSER file://$($__READLINK -f $DIR_OUTPUT) &"
	else
		cmdBrowser="$WEB_BROWSER http://$SERVER_HOST:$SERVER_PORT &"
	fi

	sleep 1s && eval "$cmdBrowser" >&2 2>/dev/null
	if [[ -n "$SERVER_START" ]]; then
		printf '(Use CTRL+C to stop the "%s" web server)\n' \
			"$SERVER_TYPE"
		printf 'SERVER_START=%s' "$SERVER_START"
		eval "$SERVER_STOP >&2 2>/dev/null"; eval "$SERVER_START"
	fi

} #::preview-website()


#-------------------------------------------------------------------------------
# ::delete-directories
#
#   Deletes DIR_BUILD and DIR_OUTPUT if there is pending processing.
#
# parent: webera::main
#
webera::delete-directories() {

	[[ "$DO_DELETE_DIR_BUILD" == true ]] && rm -rf -- "$DIR_BUILD" 2>/dev/null

	if [[ "$_DO_DELETE_DIR_OUTPUT" == true ]] && \
		[[ $_DO_PROCESS_RESOURCES == true \
		|| $_DO_PROCESS_TEMPLATES == true ]]; then
		rm -rf -- "$DIR_OUTPUT" 2>/dev/null
	fi

} #::delete-directories()


#-------------------------------------------------------------------------------
# ::read-config
#
#   Reads some configuration from a file or a string,
#   and joins it together to a common source.
#
# argument: $1 : $configType [file|string]
# argument: $2 : $configPointer can be either the file name or the variable name
#     exit: 10 : unknown config type
#   parent: webera::main
#
webera::read-config() {

	declare configType="$1" configPointer="$2"
	declare readConfig configLine

	if [[ "$configType" == "string" ]]; then
		if [[ -n "${!configPointer}" ]]; then # string is not empty
			webera::log 3 "Reading settings passed as an argument."
			readConfig="$(printf '%s' "${!configPointer}" \
				| $__SED -e "$_SED_TRIM_WS" \
				| $__SED -e "$_SED_DEL_COMMENTS" -e "$_SED_DEL_EMPTYLINES" \
				| $__SED -e "$_SED_JOIN_SPLITLINES" \
			)"$'\n'
			_CONFIG_JOINT+="$readConfig"
			webera::push-vars strn "" "$readConfig"
		fi

	elif [[ "$configType" == "file" ]]; then
		if [[ -f "$configPointer" ]]; then # file exists

			if [[ "$_DO_GENERATE_CONFIG_FILE" == true ]]; then
				webera::log 2 warn "Warning: automatic override of an existing " \
					"local config file ('$configPointer') is not permitted."
			else
				webera::log 3 "Reading settings from file '$configPointer'"
				readConfig="$(sed -e "$_SED_TRIM_WS" "$configPointer" \
					| $__SED -e "$_SED_DEL_COMMENTS" -e "$_SED_DEL_EMPTYLINES" \
					| $__SED -e "$_SED_JOIN_SPLITLINES" \
				)"$'\n'
				_CONFIG_JOINT+="$readConfig" # append
				webera::push-vars file "$configPointer" "$readConfig"
			fi

		else # config file doesn't exist
			# it's the config file of the project
			if [[ "$configPointer" == "$_CONFIG_FILE" ]]; then
				 # stop if printing debug info
				[[ "$_DO_PRINT_VARS" == true ]] && return 0

				if [[ "$_DO_GENERATE_CONFIG_FILE" == true ]]; then
					webera::generate-config
				else
					webera::log 3 warn "Warning: project's config file " \
						"'$_CONFIG_FILE' doesn't exist."
				fi
			fi
		fi
	else
		webera::log error "Error: unknown config type"
		exit 10
	fi

} #::read-config()


#-------------------------------------------------------------------------------
# ::configure-settings
#
#   Parses the configuration settings and overrides them with:
#   1) the joint configuration 2) the passed arguments.
#
# parent: webera::main
#
webera::configure-settings() {

	declare settingsList setting arg settingName settingValue settingPrevious

	settingsList="$(printf '%s' "$_CONFIG_JOINT" | $__GREP "^$_WS*config$_WS*:" )"

	if [[ -n "$settingsList" ]]; then
		webera::log 1 "\nConfiguring settings...\n$_HL"

		local IFSbkp="$IFS"; IFS=$'\n'
		for setting in $settingsList; do
			settingName=$(printf '%s' "$setting" \
				| cut -d':' -f2 \
				| $__SED -e "$_SED_TRIM_WS")
			settingValue=$(printf '%s' "$setting" \
				| cut -d':' -f3- \
				| $__SED -e "$_SED_TRIM_WS")

			[[ -n "${!settingName}" ]] &&
				settingPrevious="(previous=${!settingName})"
			webera::log 1 "${_IN}setting: $settingName=$settingValue " \
				"$settingPrevious"

			[[ "$setting" != _* ]] && # read (only public) settings from file
				printf -v "$settingName" '%s' "$settingValue"
		done
		IFS="$IFSbkp"
	fi

	# Override the settings with the parsed arguments
	for arg in "${!_ARG_OPTIONS[@]}"; do
		printf -v "$arg" '%s' "${_ARG_OPTIONS[$arg]}"
		printf -v __VARS_WEBERA '%s' \
			"$__VARS_WEBERA"$'\n'"[args]::$arg=${_ARG_OPTIONS[$arg]}"
	done

} #::configure-settings()


#-------------------------------------------------------------------------------
# ::generate-config
#
#   Generates a config file, writing down the settings modified via arguments.
#
# parent: webera::main : when the script received the `-n` flag
#
webera::generate-config() {

	local configLines=()
	declare opt line

	for opt in "${!_ARG_OPTIONS[@]}"; do
		[[ "$opt" != _* ]] && # write (only public) vars to config file
			configLines+=("config : $opt : ${_ARG_OPTIONS[$opt]}")
	done

	touch "$_CONFIG_FILE"
	for line in "${configLines[@]}"; do
		printf '%s\n' "$line" >> "$_CONFIG_FILE"
	done

} #::generate-config()


#-------------------------------------------------------------------------------
# ::read-config-commands
#
#   Reads the configuration commands for processing templates and resources.
#
# parent: webera::main
#
webera::read-config-commands() {

	declare commandList cmd commandNum commandName commandAction

	commandList="$(printf '%s' "$_CONFIG_JOINT" | $__GREP "^$_WS*command$_WS*:" )"

	if [[ -n "$commandList" ]]; then
		commandNum=$(printf '%s\n' "$commandList" | wc -l )
		webera::log 1 "\nParsing commands...\n$_HL"
		webera::log 1 "${_IN}Found $commandNum defined command:"
	else return 0; fi

	local IFSbkp="$IFS"; IFS=$'\n'
	for cmd in $commandList; do # [OPTIMIZE]
		commandName=$(printf '%s' "$cmd" \
			| cut -d':' -f2 \
			| $__SED -e "$_SED_TRIM_WS" )
		commandAction=$(printf '%s' "$cmd" \
			| cut -d':' -f3- \
			| $__SED -e "$_SED_TRIM_WS" )

		_DEFINED_CMD_MAP["$commandName"]="$commandAction"

		webera::log 2 "${_IN}$commandName='$commandAction'"
	done
	IFS="$IFSbkp"

} #::read-config-commands()


#-------------------------------------------------------------------------------
# ::process-resources
#
#   Parses the configuration and executes the resource operations.
#
# return:    8 : no resources directory found
# parent: webera::main : when the script received the `-r` flag
#
webera::process-resources() {

	declare resourceOpList resourceOpNum resourceOp
	declare operation fileOrigin fileTarget command

	webera::log 1 "\nProcessing resources...\n$_HL"

	if [[ ! -d "$DIR_RESOURCES" ]]; then
		webera::log 1 error "No resources dir '$DIR_RESOURCES' found."
		return 8
	fi

	resourceOpList="$(printf '%s' "$_CONFIG_JOINT" \
		| $__GREP "^$_WS*resource$_WS*:" )"
	resourceOpNum=$(printf '%s\n' "$resourceOpList" \
		| $__SED "$_SED_DEL_EMPTYLINES" \
		| wc -l )
	webera::log 1 "${_IN}Found $resourceOpNum operations on resources:"

	local IFSbkp="$IFS"; IFS=$'\n'
	for resourceOp in $resourceOpList; do # [OPTIMIZE]
		operation=$(printf '%s' "$resourceOp" \
			| cut -d':' -f2 \
			| $__SED -e "$_SED_TRIM_WS" )
		fileOrigin=$(printf '%s' "$resourceOp" \
			| cut -d':' -f3 \
			| $__SED -e "$_SED_TRIM_WS" )
		fileTarget=$(printf '%s' "$resourceOp" \
			| cut -d':' -f4 \
			| $__SED -e "$_SED_TRIM_WS" )

		webera::log 1 "${_IN}$operation: $fileOrigin > $fileTarget"

		if [[ ! -e "$DIR_RESOURCES/$fileOrigin" ]]; then
			webera::log 1 error "${_IN}ERROR: '$fileOrigin' don't exist"
			continue # XXX do break instead?
		fi

		case "$operation" in
			"copy")
				mkdir -p -- "$DIR_OUTPUT/$DIR_RESOURCES/$(dirname "$fileTarget")"
				cp -r -- "$DIR_RESOURCES/$fileOrigin" \
					"$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget"
				;;
			*)
				# On custom commands, {PATHS} tags are adapted for resources
				if [[ -n "${_DEFINED_CMD_MAP[$operation]}" ]]; then

					command=$(printf '%s' "${_DEFINED_CMD_MAP[$operation]}" \
						| $__SED "s|{ORIGIN}|$DIR_RESOURCES/$fileOrigin|g" \
						| $__SED "s|{BUILD}|$DIR_BUILD/$fileOrigin|g" \
						| $__SED "s|{TARGET}|$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget|g")

					# Create target paths
					if [[ "${_DEFINED_CMD_MAP[$operation]}" == *"{BUILD}"* ]]; then
						mkdir -p -- "$(dirname "$DIR_BUILD/$fileTarget")"
					fi
					if [[ "${_DEFINED_CMD_MAP[$operation]}" == *"{TARGET}"* ]]; then
						mkdir -p -- "$(dirname \
							"$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget")"
					fi

					webera::log 3 "${_IN}Executing: $command"
					eval "$command"
				else
					webera::log 1 error \
						"${_IN}ERROR: operation '$operation' not recognized"
				fi
				;;
		esac
	done
	IFS="$IFSbkp"

} #::process-resources()


#-------------------------------------------------------------------------------
# ::process-templates
#
#   Parses the configuration and executes the template operations.
#
# return:    9 : no templates directory found
# parent: webera::main : when the script received the `-t` flag
#
webera::process-templates() {

	declare templateOpList templateOpNum templateOp
	declare operation fileOrigin fileTarget command

	webera::log 1 "\nProcessing templates...\n$_HL"

	if [[ ! -d "$DIR_TEMPLATES" ]]; then
		webera::log 1 error "No templates dir '$DIR_TEMPLATES' found."
		return 9
	fi

	templateOpList="$(printf '%s' "$_CONFIG_JOINT" \
		| $__GREP "^$_WS*template$_WS*:" )"

	templateOpNum=$(printf '%s\n' "$templateOpList" \
		| $__SED "$_SED_DEL_EMPTYLINES" \
		| wc -l )
	webera::log 1 "${_IN}Found $templateOpNum operations on templates:"

	local IFSbkp="$IFS"; IFS=$'\n'
	for templateOp in $templateOpList; do
		operation=$(printf '%s' "$templateOp" \
			| cut -d':' -f2 \
			| $__SED -e "$_SED_TRIM_WS" )
		fileOrigin=$(printf '%s'  "$templateOp" \
			| cut -d':' -f3 \
			| $__SED -e "$_SED_TRIM_WS" )
		fileTarget=$(printf '%s' "$templateOp" \
			| cut -d':' -f4 \
			| $__SED -e "$_SED_TRIM_WS" )

		webera::log 1 "${_IN}$operation: $fileOrigin > $fileTarget"

		case "$operation" in
			"route")
				if [[ -n "$fileOrigin" && -n "$fileTarget" ]]; then
					# A path ending in `/`, will be a dir_name/index.html
					if [[ "$fileTarget" == */ ]]; then
						mkdir -p -- "${DIR_OUTPUT}/${fileTarget}"
						webera::render-template "$fileOrigin" > \
							"${DIR_OUTPUT}/${fileTarget}/index.html"
					else
						mkdir -p -- "$(dirname "${DIR_OUTPUT}/${fileTarget}")"
						webera::render-template "$fileOrigin" > \
							"${DIR_OUTPUT}/${fileTarget}"
					fi
				else
					webera::log 1 error "${_IN}ERROR: missing arguments for" \
						"'template:route' operation"
				fi
				;;

			*)
				# On custom commands, the {PATHS} tags are adapted for templates
				if [[ -n "${_DEFINED_CMD_MAP[$operation]}" ]]; then

					command=$(printf '%s' "${_DEFINED_CMD_MAP[$operation]}" \
						| $__SED "s|{ORIGIN}|$DIR_TEMPLATES/$fileOrigin|g" \
						| $__SED "s|{BUILD}|$DIR_BUILD/$fileOrigin|g" \
						| $__SED "s|{TARGET}|$DIR_OUTPUT/$fileTarget|g" \
					)

					# Create target paths
					if [[ "${_DEFINED_CMD_MAP[$operation]}" == *"{BUILD}"* ]]; then
						mkdir -p -- "$(dirname "$DIR_BUILD/$fileTarget")"
					fi
					if [[ "${_DEFINED_CMD_MAP[$operation]}" == *"{TARGET}"* ]]; then
						mkdir -p -- "$(dirname "$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget")"
					fi

					webera::log 3 "${_IN}Executing: $command"
					eval "$command"
				else
					webera::log 1 error \
						"${_IN}ERROR: operation '$operation' not recognized"
				fi
				;;
		esac
	done
	IFS="$IFSbkp"

} #::process-templates()


#-------------------------------------------------------------------------------
# ::parse-template-includes
#
#   Recursively parses a template for include directives, and then
#   joins all the parts together in a single template.
#
# argument: $1 : templateFileName
#   return:  7 : No template found
#     exit:  3 : Maximum nesting level overflow
#   parent: webera::render-template
#
webera::parse-template-includes() {

	declare templateFileName=$1
	declare templateContent directive directives_include incFileName incFileContent

	((_NESTING_LEVEL++))

	if [[ "$_NESTING_LEVEL" -gt "$NESTING_MAX" ]]; then
		webera::log 1 error "${_IN}ERROR: max nesting level ($NESTING_MAX)" \
			"reached for template $templateFileName"
		exit 3
	fi

	# Parse template
	local templateFile="${DIR_TEMPLATES}/$templateFileName"
	if [[ -f "$templateFile" ]]; then
		templateContent="$(<"$templateFile")"
	else
		webera::log 1 error "${_IN}ERROR: No template found '$templateFile'"
		return 7
	fi
	directives_include=$($__GREP -Po "<!--$_WS*%include$_WS*:.*?-->" \
		"$templateFile") # [INC01]

	# Remove duplicates
	if [[ -n "$directives_include" ]]; then
		directives_include=$(printf '%s' "$directives_include" | uniq)
	fi

	local IFSbkp="$IFS"; IFS=$'\n'
	for directive in $directives_include; do
		incFileName=$(webera::get-directive-content "$directive" '%include')
		webera::log 2 "${_IN2}include: '$incFileName'"

		# Parse included template for further includes
		incFileContent="$(webera::parse-template-includes "${incFileName}")"

		# Mass-replace directive with template contents
		templateContent="${templateContent//$directive/$incFileContent}"
	done
	IFS="$IFSbkp"

	((_NESTING_LEVEL--))

	printf '%s' "$templateContent"

} #::parse-template-includes()


#-------------------------------------------------------------------------------
# ::render-template
#
#   Parses the template, processes the directives and renders the html file.
#
# argument: $1 : templateFileName
#   parent: webera::process-templates (when parsing the 'route' command)
#
webera::render-template() {

	declare templateFileName=$1

	declare templateText directives_set directives_cmd directives_setcmd
	declare directive setVarVal setVar setValue cmd cmdOutput
	declare setCmdVar setCmdValue setCmd setCmdOutput
	declare -i cmdOutputLength maxOutputLength=50 # in characters

	templateText="$(webera::parse-template-includes "$templateFileName")"

	# text comments
	#
	# <!-- // Comment -->
	#
	templateText=$(printf '%s' "$templateText" \
		| $__SED -e :a -re "s/<!--$_WS*\/\/.*?-->//g;/<!--\/\//N;//ba")

	local IFSbkp="$IFS"; IFS=$'\n'

	# set variables
	#
	# <!-- %set : VARIABLE=something -->
	# <!-- @VARIABLE -->
	#
	directives_set=$(printf '%s' "$templateText" \
		| $__GREP -Po "<!--$_WS*%set$_WS*:.*?-->") # [INC01]

	for directive in $directives_set; do
		setVarVal=$(webera::get-directive-content "$directive" '%set')
		setVar="${setVarVal%%=*}"
		setValue="${setVarVal#*=}"
		webera::log 3 "${_IN3}set: $setVar = $setValue"

		# Cross-platform syntax to replace including newlines
		# http://stackoverflow.com/a/1252191
		templateText=$(printf '%s' "$templateText" \
			| $__SED -e ":a" -e "N" -e "\$!ba" -e "s/$directive\n\?//g")
		templateText=$(printf '%s' "$templateText" \
			| $__SED -e ":a" -e "N" -e "\$!ba" \
			-e "s/<!--$_WS*@$setVar$_WS*-->\n\?/$setValue/g")
	done

	# execute commands, render output
	#
	# <!-- %cmd : ls -l -->
	#
	directives_cmd=$(printf '%s' "$templateText" \
		| $__GREP -Po "<!--$_WS*%cmd$_WS*:.*?-->") # [INC01]

	for directive in $directives_cmd ; do
		cmd=$(webera::get-directive-content "$directive" '%cmd')
		cmdOutput=$(eval "$cmd")
		webera::log 3 "${_IN2}cmd: $cmd"

		cmdOutputLength=$(printf "%s" "$cmdOutput" | wc -c)

		if [[ "$cmdOutputLength" -le "$maxOutputLength" ]]; then
			webera::log 3 "${_IN3}=: $cmdOutput"
		else
			webera::log 3 "${_IN3}=: $(printf '%s' "$cmdOutput" \
				| tr '\n' ' ' \
				| head -c$maxOutputLength) (...) +" \
				"$((cmdOutputLength-maxOutputLength)) chars"
		fi

		# Substitute the directive in the template with the command output
		# http://stackoverflow.com/a/40749641/940200
		templateText=$($__AWK -v repl="$cmdOutput" 'FNR==NR {
				a = a $0; next
			}
			n = index($0, a) {
				$0 = substr($0, 1, n-1) repl substr($0, n+length(a))
			} 1' <(printf '%s\n' "$directive") <(printf '%s' "$templateText")
		)
	done

	# set variables to commands output
	#
	# <!-- %setcmd : VARIABLE=ls -l -->
	# <!-- @VARIABLE -->
	#
	directives_setcmd=$(printf '%s' "$templateText" \
		| $__GREP -Po "<!--$_WS*%setcmd$_WS*:.*?-->") # [INC01]

	for directive in $directives_setcmd; do
		setCmd=$(webera::get-directive-content "$directive" '%setcmd')
		setCmdVar="${setCmd%%=*}"
		setCmdValue="${setCmd#*=}"
		setCmdOutput=$(eval "$setCmdValue")
		webera::log 3 "${_IN2}setcmd: $setCmdVar = $setCmdValue"

		# Delete the directive from the template
		templateText=$($__AWK -v 'FNR==NR {
				a = a $0; next
			}
			n = index($0, a) {
				$0 = substr($0, 1, n-1) substr($0, n+length(a))
			} 1' <(printf '%s\n' "$directive") <(printf '%s' "$templateText")
		)
		# Replace all the set variables with the command output
		templateText=$(printf '%s' "$templateText" \
			| $__SED -e ":a" -e "N" -e "\$!ba" \
			-e "s/<!--$_WS*@$setCmdVar$_WS*-->\n\?/$setCmdOutput/g")
	done

	IFS="$IFSbkp"

	webera::log 3

	printf "%s" "$templateText"

} #::render-template()


#-------------------------------------------------------------------------------
# ::get-directive-content
#
#   Checks for dependencies and displays pertinent information.
#
# argument: $1 : whole directive
# argument: $2 : directive identifier (e.g. %include)
# parent: webera::render-template
webera::get-directive-content() {

	printf '%s' "$1" \
		| $__SED -n -e "s/<\!--$_WS*$2$_WS*:$_WS*\(.*\)$_WS*-->/\1/p" \
		| $__SED -e "s/$_WS*$//"

} #::get-directive-content()


#-------------------------------------------------------------------------------
# ::check-compatibility
#
#   Checks for dependencies and displays pertinent information.
#
#   exit: 6 : bash version too old
# parent: webera::main
#
webera::check-compatibility() {

	# Bash version >= 4
	if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
		printf '%s\n' "Bash version >=4 needed. Current version is $BASH_VERSION"

		if [[ "$(uname)" == 'Darwin' ]]; then
			printf 'You can install it with Brew (http://brew.sh)\n like this:'
			printf 'brew install bash\n'
		fi
		exit 6
	fi

	# prefer the GNU version of the Unix commands used, specially in Mac OS X
	__SED="$(webera::find-gnu-cmd sed)"
	__AWK="$(webera::find-gnu-cmd  awk)"
	__GREP="$(webera::find-gnu-cmd grep)"
	__DATE="$(webera::find-gnu-cmd date)"
	__READLINK="$(webera::find-gnu-cmd readlink)"

} #::check-compatibility()


#-------------------------------------------------------------------------------
# ::find-gnu-cmd
#
#   Returns the resolved command, preferring the GNU versions
#   and falling back to the standard version when not found.
#
webera::find-gnu-cmd() {

	local default_cmd="$1"
	local gnu_cmd="g$default_cmd"

	if [[ "$(which "$gnu_cmd" 2> /dev/null)" ]]; then
		printf '%s' "$gnu_cmd"
	else
		printf '%s' "$default_cmd"
	fi

} #::find-gnu-cmd()


#-------------------------------------------------------------------------------
# ::setup-debugging
#
#   Enables xtrace if WEBERA_DEBUG has been defined, and sets a nice formatting.
#
# parent: webera::main
#
# shellcheck disable=SC2016
webera::setup-debugging() {

	local ps4_date='[$(($($__DATE "+%s%3N")-__WEBERA_TIME_STAMP))ms]' # [INC02]
	local ps4_line='L$LINENO'
	local ps4_func='${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

	[[ -n "$WEBERA_DEBUG" ]] && set -o xtrace && \
		export PS4="+ $ps4_date $ps4_line $ps4_func"

} #::setup-debugging()


#-------------------------------------------------------------------------------
# ::print-vars
#
#   Prints all the script "global" settings and data, public and private.
#
webera::print-vars() { printf '%s\n' "$__VARS_WEBERA"; }


#-------------------------------------------------------------------------------
# ::push-vars
#
#   Parses configuration, extracts the config variables and appends them
#   to __VARS_WEBERA in the correct format, using the provided arguments.
#
# argument: $1 : varOrigin [vdef|args|file|strn]
# argument: $2 : varPath (for files)
# argument: $3 : configuration
#   parent: webera::read-config
#
webera::push-vars() {

	declare varOrigin="$1" varPath="$2" configuration="$3"
	declare configLine

	local IFSbkp="$IFS"; IFS=$'\n'
	for configLine in $(printf '%s' "$configuration" \
		| $__GREP '^config' \
		| cut -d ':' -f2- \
		| $__SED "s/$_WS*:$_WS*/=/" \
		| $__SED "$_SED_TRIM_WS" \
		); do
		if [[ "$configLine" != _* ]]; then # only read public variables
			printf -v __VARS_WEBERA '%s' \
			"$__VARS_WEBERA"$'\n'"[$varOrigin]:$varPath:$configLine"
		fi
	done
	IFS="$IFSbkp"

} #::push-vars()


#-------------------------------------------------------------------------------
# ::elapsed-time
#
#   Prints the spent time on the script, in milliseconds.
#
# argument: $1 : when true, prints the time beautified
#
webera::elapsed-time() {

	local -ir timeStampFinal="$($__DATE '+%s%3N')"
	local -ir timeElapsed="$((timeStampFinal-__WEBERA_TIME_STAMP))"
	if [[ "$1" == true ]]; then
		printf '%s' "$(webera::beautify-time "$timeElapsed")"
	else
		printf '%s' "$timeElapsed"
	fi

} #::elapsed-time()


#-------------------------------------------------------------------------------
# ::beautify-time
#
#   Tries to format a time in milliseconds into a human readable text string
#   showing the days, hours, minutes and/or seconds contained in that time.
#
# argument: $1 : time in milliseconds
#
webera::beautify-time() {

	local -ir ms="$1"
	local -ir s="$((ms/1000%60))"
	local -ir m="$((ms/60000%60))"
	local -ir h="$((ms/3600000%24))"
	local -ir d="$((ms/86400000))"

	declare timeString didTime

	[[ "$d" -gt 0 ]] && timeString+="${d}d " && didTime=true
	[[ "$h" -gt 0 || -n "$didTime" ]] && timeString+="${h}h " && didTime=true
	[[ "$m" -gt 0 || -n "$didTime" ]] && timeString+="${m}m " && didTime=true
	[[ -n "$didTime" ]] && timeString+="${s}s " # shows seconds if time > 1m
	[[ "$m" -lt 1 && -z "$didTime" ]] && timeString+="${ms}ms "

	printf '%s' "${timeString}"

} #::beautify-time()


[[ "$0" == "${BASH_SOURCE[0]}" ]] && webera::main "$@" # Run if not sourced
