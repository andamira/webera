#!/usr/bin/env bash
#
# webera
# a handy shellscript for static website generation
#
# Repository: https://github.com/andamira/webera
# Author: Jos√© Luis Cruz
# Version: 0.1.39
# License: MIT
#
# Dependencies:
#     bash 4, grep -P, sed, awk, coreutils
##

main() {
	__setupDebugging
	__checkCompatibility
	local __VARS_WEBERA="" # a list of all the settings (-_)
	local __VARS_BEFORE=$(set -o posix ; set | awk -F= '{print $1"="}' )


	## CONFIGURABLE SETTINGS

	# Paths
	local DIR_TEMPLATES=tem
	local DIR_RESOURCES=res
	local DIR_BUILD=build
	local DIR_OUTPUT=out
	local FILE_CONFIG=.weberarc

	# Web Browser
	local WEB_BROWSER="firefox"
	local SERVER_TYPE="python"
	local -i SERVER_PORT=8192
	local SERVER_HOST="localhost"
	local SERVER_START=""
	local SERVER_STOP=""

	# Log
	local FILE_LOG=log.txt
	local OPTION_LOG_CLEAR=false
	local -i OPTION_LOG_LEVEL=0 # 0 = no log | 1 | 2 | 3

	# Delete output & build directories
	local OPTION_DELETE_DIR_OUTPUT=true
	local OPTION_DELETE_DIR_BUILD=true


	## INTERNAL SETTINGS

	local _OPERATIONAL=false

	local _DO_PROCESS_TEMPLATES=false
	local _DO_PROCESS_RESOURCES=false
	local _DO_PREVIEW_IN_BROWSER=false

	local _DO_GENERATE_FILE_CONFIG=false # has it been requested to generate? (-n)
	local _FILE_CONFIG_EXPLICIT=false # has it been explicitly indicated?  (-C)

	declare -A _ARG_OPTIONS
	declare -A _DEFINED_CMD_MAP

	local -i _NESTING_LEVEL=0
	local -ri _NESTING_MAX=8

	local _PRELOG="" # where log is saved before there's a logfile
	local -r _DATE=$(date '+%Y-%m-%d %H:%M:%S')
	local -i _LOG_LEVEL_MIN=1
	local -i _LOG_LEVEL_MAX=3

	# log indentation and formatting
	declare -r _IN="  " _IN2="    " _IN3="      "
	local -r _HEADING='------------------------------------------------------'

	# reusable regexp patterns
	local -r _WS="[[:space:]]" # whitespace
	local -r _SED_TRIM_WS="s/^$_WS*//;s/$_WS*$//"
	local -r _SED_DEL_COMMENTS="/^$_WS*#.*/d" # starting in #
	local -r _SED_DEL_EMPTYLINES="/^$_WS*$/d"
	local -r _SED_JOIN_SPLITLINES=':x; /\\$/ { N; s/\\\n//; tx }' # ending in \


	# -- Save the default settings
	local __VARS_AFTER="$(set -o posix ; set | sed '/^'\''/d' )"
	printf -v __VARS_WEBERA '%s' "$(grep -vFf \
		<(printf '%s' "$__VARS_BEFORE") <(printf '%s' "$__VARS_AFTER") \
		| sed 's/^/[vdef]::/' )"
	unset __VARS_BEFORE; unset __VARS_AFTER;
	local __DO_PRINT_VARS=false


	## MAIN PROCESS

	log "\n===============[$_DATE]==============@\n" 1

	parseArguments "$@"

	[[ "$FILE_CONFIG" != "/etc/weberarc" ]] && readConfig "/etc/weberarc"
	[[ "$FILE_CONFIG" != "$HOME/.weberarc" ]] && readConfig "$HOME/.weberarc"
	readConfig "$FILE_CONFIG"

	configureSettings

	if [[ "$__DO_PRINT_VARS" == true ]]; then __printVars; return $?; fi

	setupLog

	deleteDirectories

	readConfigCommands

	[[ "$_DO_PROCESS_RESOURCES" == true ]] && processResources
	[[ "$_DO_PROCESS_TEMPLATES" == true ]] && processTemplates

	[[ "$_DO_PREVIEW_IN_BROWSER" == true ]] \
		&& serverSetup && previewWebsite
} #main()

usage() {
	local errCode="$1"

	cat <<-ENDUSAGE
	Usage: ./webera -[trwn] [optional flags]

	MAIN FLAGS

	  -t              process the templates
	  -r              process the resources
	  -w              preview in web browser

	  -n              generate a new configuration file

	OPTIONAL          ... (DEFAULT)

	  -C <FILE>       indicate the configuration file ($FILE_CONFIG)

	  -T <DIR>        indicate the templates directory ($DIR_TEMPLATES)
	  -R <DIR>        indicate the resources directory ($DIR_RESOURCES)
	  -O <DIR>        indicate the output directory ($DIR_OUTPUT)
	  -B <DIR>        indicate the build directory ($DIR_BUILD)

	  -d              switch deleting the output dir (delete=$OPTION_DELETE_DIR_OUTPUT)
	  -c              switch clearing the log file (clear=$OPTION_LOG_CLEAR)

	  -L <NUMBER>     log level [0=none|1|2|3] ($OPTION_LOG_LEVEL)
	  -G <FILE>       log file ($FILE_LOG)

	  -W <BIN>        web browser binary ($WEB_BROWSER)
	  -S <TYPE>       server type [none|php|python|custom] ($SERVER_TYPE)
	  -H <DOMAIN>     server host ($SERVER_HOST)
	  -P <NUMBER>     port number ($SERVER_PORT)
	ENDUSAGE
	[[ -z "$errCode" ]] || exit "$errCode"
} #usage()

parseArguments() {
# $@ = all the arguments

	local OPTIND OPTION

	while getopts ':trwnC:T:R:O:B:dcL:G:W:S:H:P:_h:' OPTION; do
		case "$OPTION" in
			t) _OPERATIONAL=true; _ARG_OPTIONS[_DO_PROCESS_TEMPLATES]=true ;;
			r) _OPERATIONAL=true; _ARG_OPTIONS[_DO_PROCESS_RESOURCES]=true ;;
			w) _OPERATIONAL=true; _ARG_OPTIONS[_DO_PREVIEW_IN_BROWSER]=true ;;

			n) _OPERATIONAL=true; _DO_GENERATE_FILE_CONFIG=true;
				_ARG_OPTIONS[_DO_GENERATE_FILE_CONFIG]=true ;;

			C) FILE_CONFIG="$OPTARG"
				_ARG_OPTIONS[FILE_CONFIG]="$OPTARG"
				_FILE_CONFIG_EXPLICIT=true;
				;;

			# The following options can also be defined in $FILE_CONFIG, but
			# passing them as arguments to the script has a higher priority.

			T) _ARG_OPTIONS[DIR_TEMPLATES]="$OPTARG" ;;
			R) _ARG_OPTIONS[DIR_RESOURCES]="$OPTARG" ;;
			O) _ARG_OPTIONS[DIR_OUTPUT]="$OPTARG" ;;
			B) _ARG_OPTIONS[DIR_BUILD]="$OPTARG" ;;

			# These flags switches the default boolean value,
			# (without checking first the values in file config).
			d) if [[ "$OPTION_DELETE_DIR_OUTPUT" == true ]]; then
					_ARG_OPTIONS[OPTION_DELETE_DIR_OUTPUT]=false
				else
					_ARG_OPTIONS[OPTION_DELETE_DIR_OUTPUT]=true
				fi
				;;
			c) if [[ "$OPTION_LOG_CLEAR" == true ]]; then
					_ARG_OPTIONS[OPTION_LOG_CLEAR]=false
				else
					_ARG_OPTIONS[OPTION_LOG_CLEAR]=true
				fi
				;;

			L) _ARG_OPTIONS[OPTION_LOG_LEVEL]="$OPTARG" ;;
			G) _ARG_OPTIONS[FILE_LOG]="$OPTARG" ;;

			W) _ARG_OPTIONS[WEB_BROWSER]="$OPTARG" ;;
			S) _ARG_OPTIONS[SERVER_TYPE]="$OPTARG" ;;
			H) _ARG_OPTIONS[SERVER_HOST]="$OPTARG" ;;
			P) _ARG_OPTIONS[SERVER_PORT]="$OPTARG" ;;

			_) _OPERATIONAL=true; __DO_PRINT_VARS=true ;; # hidden arg

			h) usage 0 ;;
			*) usage 1 ;;
		esac
	done
	shift $((OPTIND-1))
} #parseArguments()

setupLog() {

	if [[ "$OPTION_LOG_CLEAR" == true ]]; then
		log "\nWarning: deleting previous log file '$FILE_LOG'" 3 warn
		rm "$FILE_LOG" 2>/dev/null;
	fi

	# Write the pre-saved log to the file
	#
	# 1. filter out the lines with greater than current log level
	# 2. leave only the log message, discard the rest. (TODO: filter out error|warn)
	# 3. bring back the newlines
	# 4. put the log level in the date header
	local PARSED_PRELOG=$(printf "$_PRELOG" \
		| awk -v ll=$OPTION_LOG_LEVEL -F '|' '$1<=ll' \
		| cut -d'|' -f3- \
		| tr '\a' '\n' \
		| sed "s/====@$/====$OPTION_LOG_LEVEL/" )

	_PRELOG=false

	[[ -z "$PARSED_PRELOG" ]] || log "$PARSED_PRELOG"
} #setupLog()

log() {
	declare logMsg=$1 logLevelNeeded=$2 logType=$3

	if [[ "$_PRELOG" == false ]]; then
		if [[ -z "$logLevelNeeded" || ( "$logLevelNeeded" -lt "1" ) ]]; then
			LOG_LEVEL="$_LOG_LEVEL_MIN"
		else
			if [[ "$LOG_LEVEL" -gt "$_LOG_LEVEL_MAX" ]]; then
				LOG_LEVEL="$_LOG_LEVEL_MAX"
			else
				LOG_LEVEL="$logLevelNeeded"
			fi
		fi

		if [[ "$LOG_LEVEL" -le "$OPTION_LOG_LEVEL" ]]; then
			printf "$logMsg\n" >> "$FILE_LOG" # FIXME SYNTAX
		fi
	else
		# Pre-save this log message as a single line
		#
		# 1. replace the newlines with a BEL
		# 2. put the log level and type at the beginning
		local msg_1line=$(printf "$logMsg" | tr '\n' '\a')
		_PRELOG+="\n$logLevelNeeded|$logType|$msg_1line"
	fi

	# Print errors to stderr
	if [[ "$logType" == "error" ]]; then
		printf "$logMsg\n" 1>&2
	fi
} # log()

serverSetup() {
	case "$SERVER_TYPE" in
		python)
			SERVER_START="pushd \"$DIR_OUTPUT\"; python -m SimpleHTTPServer $SERVER_PORT"
			SERVER_STOP='kill $(pgrep -f "python -m SimpleHTTPServer")'
			;;
		php)
			SERVER_START="php -S localhost:$SERVER_PORT -t \"$DIR_OUTPUT\""
			SERVER_STOP='kill $(pgrep -f "php -S localhost")'
			;;
		none) # useful when not using `dir/index.html` structure
			SERVER_START=""
			SERVER_STOP=""
			;;
		custom) # for when a server is already running, or custom SERVER_START
			;;
		*)
			log "ERROR: Not recognized SERVER_TYPE='$SERVER_TYPE'" 2 error
			exit 5
			;;
	esac
} #serverSetup()

previewWebsite() {
	printf "Loading website in '$WEB_BROWSER'...\n"

	if [[ "$SERVER_TYPE" == "none" ]]; then
		local RUN_BROWSER="$WEB_BROWSER file://$(readlink -f $DIR_OUTPUT) &"
	else
		local RUN_BROWSER="$WEB_BROWSER http://$SERVER_HOST:$SERVER_PORT &"
	fi

	sleep 1s && eval "$RUN_BROWSER" >&2 2>/dev/null
	if [[ -n "$SERVER_START" ]]; then
		printf "(Use CTRL+C to stop the '$SERVER_TYPE' web server)\n"
		printf "SERVER_START=$SERVER_START"
		eval "$SERVER_STOP >&2 2>/dev/null"; eval "$SERVER_START"
	fi
} #previewWebsite()

deleteDirectories() {

	[[ "$OPTION_DELETE_DIR_BUILD" == true ]] && rm -rf "$DIR_BUILD" 2>/dev/null

	if [[ "$OPTION_DELETE_DIR_OUTPUT" == true ]] && \
		[[ $_DO_PROCESS_RESOURCES == true \
		|| $_DO_PROCESS_TEMPLATES == true ]]; then
		rm -rf "$DIR_OUTPUT" 2>/dev/null
	fi
} #deleteDirectories()

readConfig() {
	local FILE="$1" # string

	if [[ -f "$FILE" ]]; then # the config file exists already

		if [[ "$_DO_GENERATE_FILE_CONFIG" == true ]] \
			&& [[ "$FILE" == "$FILE_CONFIG" ]]; then
			log "Warning: local config file '$FILE' already exists. Overwrite is not allowed." 2 warn
		fi

		local TMPCONF="$(cat "$FILE" \
			| sed -e "$_SED_TRIM_WS" \
			| sed -e "$_SED_DEL_COMMENTS" -e "$_SED_DEL_EMPTYLINES" \
			| sed -e "$_SED_JOIN_SPLITLINES" \
		)"$'\n'
		CONFIG+="$TMPCONF" # append new to previously read configuration

		local OLDIFS="$IFS"; IFS=$'\n'
		for LINE in $(printf '%s' "$TMPCONF" \
			| grep '^config' \
			| cut -d ':' -f2- \
			| sed "s/$_WS*:$_WS*/=/" \
			| sed "$_SED_TRIM_WS" \
			); do
			printf -v __VARS_WEBERA '%s' "$__VARS_WEBERA"$'\n'"[file]:$FILE:$LINE"
		done
		IFS="$OLDIFS"

	else # when the config file doesn't exist
		# and if it's the config file of the project
		if [[ "$FILE" == "$FILE_CONFIG" ]]; then
			[[ "$__DO_PRINT_VARS" == true ]] && return 0 # if printing debug info

			if [[ "$_DO_GENERATE_FILE_CONFIG" == true ]]; then
				generateConfig
			else
				if [[ "$_FILE_CONFIG_EXPLICIT" == true ]]; then
					printf "ERROR: Configuration file '%s' doesn't exist.\n" "$FILE_CONFIG"
					exit 2
				else
					log "Warning: project's config file '$FILE_CONFIG' doesn't exist." 3 warn
				fi
			fi
		else
			log "Warning: can't find global config file '$FILE'" 3 warn
		fi
	fi
} #readConfig()

configureSettings() {
	local SETTINGS="$(printf '%s' "$CONFIG" | grep ^$_WS*config$_WS*: )"

	if [[ -n "$SETTINGS" ]]; then
		log "\nConfiguring settings...\n$_HEADING" 1
		local OLDIFS="$IFS"; IFS=$'\n'
		for S in $SETTINGS; do
			local setting_name=$(printf '%s' "$S" | cut -d':' -f2 | sed -e "$_SED_TRIM_WS")
			local setting_value=$(printf '%s' "$S" | cut -d':' -f3- | sed -e "$_SED_TRIM_WS")
			local setting_previous_value=${!setting_name}
			log "${_IN}setting: $setting_name=$setting_value (previous=$setting_previous_value)" 1
			printf -v $setting_name "$setting_value"
		done
		IFS="$OLDIFS"
	fi

	# Override the settings with the parsed arguments
	for OPT in "${!_ARG_OPTIONS[@]}"; do
		printf -v ${OPT} "${_ARG_OPTIONS[$OPT]}"
		printf -v __VARS_WEBERA '%s' \
			"$__VARS_WEBERA"$'\n'"[args]::$OPT=${_ARG_OPTIONS[$OPT]}"
	done

	if [[ "$_OPERATIONAL" == false ]]; then
		log "You must use at least one MAIN FLAG!\n\n" 1 error
		usage 1
	fi
} #configureSettings()

generateConfig() {
	local configLines=()

	if [[ "$_FILE_CONFIG_EXPLICIT" == true ]]; then
		configLines+=("config : FILE_CONFIG : $FILE_CONFIG")
	fi

	for OPT in "${!_ARG_OPTIONS[@]}"; do
		configLines+=("config : $OPT : ${_ARG_OPTIONS[$OPT]}")
	done

	for LINE in "${configLines[@]}"; do
		printf '%s\n' "$LINE" >> "$FILE_CONFIG"
	done
} #generateConfig()

readConfigCommands() {
	local DEFINED_CMD="$(printf '%s' "$CONFIG" | grep "^$_WS*command$_WS*:" )"

	if [[ -n "$DEFINED_CMD" ]]; then
		local CNUM=$(printf '%s\n' "$DEFINED_CMD" | wc -l )
		log "\nParsing commands...\n$_HEADING" 1
		log "${_IN}Found $CNUM defined command:" 1
	else return 0; fi

	local OLDIFS="$IFS"; IFS=$'\n'
	for C in $DEFINED_CMD; do
		local cmd_name=$(printf '%s' "$C" | cut -d':' -f2 | sed -e "$_SED_TRIM_WS" )
		local cmd_action=$(printf '%s' "$C" | cut -d':' -f3- | sed -e "$_SED_TRIM_WS" )

		_DEFINED_CMD_MAP["$cmd_name"]="$cmd_action"

		log "${_IN}$cmd_name='$cmd_action'" 2
	done
	IFS="$OLDIFS"
} #readConfigCommands()

processResources() {
	log "\nProcessing resources...\n$_HEADING" 1

	if [[ ! -d "$DIR_RESOURCES" ]]; then
		log "No resources dir '$DIR_RESOURCES' found." 1 error
		return
	fi

	local RESOURCE_CMD_LIST="$(printf '%s' "$CONFIG" | grep ^$_WS*resource$_WS*: )"

	local RNUM=$(printf '%s\n' "$RESOURCE_CMD_LIST" | sed "$_SED_DEL_EMPTYLINES" | wc -l )
	log "${_IN}Found $RNUM operations on resources:" 1

	local OLDIFS="$IFS"; IFS=$'\n'
	for RCMD in $RESOURCE_CMD_LIST; do
		local operation=$(printf '%s' "$RCMD" | cut -d':' -f2 | sed -e "$_SED_TRIM_WS" )
		local fileOrigin=$(printf '%s' "$RCMD" | cut -d':' -f3 | sed -e "$_SED_TRIM_WS" )
		local fileTarget=$(printf '%s' "$RCMD" | cut -d':' -f4 | sed -e "$_SED_TRIM_WS" )

		log "${_IN}$operation: $fileOrigin > $fileTarget" 1

		if [[ ! -e "$DIR_RESOURCES/$fileOrigin" ]]; then
			log "${_IN}ERROR: '$fileOrigin' don't exist" 1 error
			continue # XXX do break instead?
		fi

		case "$operation" in
			"copy")
				mkdir -p $DIR_OUTPUT/$DIR_RESOURCES/$(dirname $fileTarget)
				cp -r "$DIR_RESOURCES/$fileOrigin" \
					"$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget"
				;;
			*)
				# On custom commands, {PATHS} tags are adapted for resources
				if [[ -n "${_DEFINED_CMD_MAP[$operation]}" ]]; then

					local CMD=$(printf '%s' "${_DEFINED_CMD_MAP[$operation]}" \
						| sed "s|{ORIGIN}|$DIR_RESOURCES/$fileOrigin|g" \
						| sed "s|{BUILD}|$DIR_BUILD/$fileOrigin|g" \
						| sed "s|{TARGET}|$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget|g" \
					)

					# Create target paths
					if [[ "${_DEFINED_CMD_MAP[$operation]}" =~ "{BUILD}" ]]; then
						mkdir -p $(dirname "$DIR_BUILD/$fileTarget")
					fi
					if [[ "${_DEFINED_CMD_MAP[$operation]}" =~ "{TARGET}" ]]; then
						mkdir -p $(dirname "$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget")
					fi

					log "${_IN}Executing: $CMD" 3
					eval "$CMD"
				else
					log "${_IN}ERROR: operation '$operation' not recognized" 1 error
				fi
				;;
		esac
	done
	IFS="$OLDIFS"
} #processResources()

processTemplates() {
	log "\nProcessing templates...\n$_HEADING" 1

	if [[ ! -d "$DIR_TEMPLATES" ]]; then
		log "No templates dir '$DIR_TEMPLATES' found." 1 error
		return
	fi

	local TEMPLATE_CMD_LIST="$(printf '%s' "$CONFIG" | grep ^$_WS*template$_WS*: )"

	local TNUM=$(printf '%s\n' "$TEMPLATE_CMD_LIST" | sed "$_SED_DEL_EMPTYLINES" | wc -l )
	log "${_IN}Found $TNUM operations on templates:" 1

	local OLDIFS="$IFS"; IFS=$'\n'
	for TCMD in $TEMPLATE_CMD_LIST; do
		local operation=$(printf '%s' "$TCMD" | cut -d':' -f2 | sed -e "$_SED_TRIM_WS" )
		local fileOrigin=$(printf '%s'  "$TCMD" | cut -d':' -f3 | sed -e "$_SED_TRIM_WS" )
		local fileTarget=$(printf '%s' "$TCMD" | cut -d':' -f4 | sed -e "$_SED_TRIM_WS" )

		log "${_IN}$operation: $fileOrigin > $fileTarget" 1

		case "$operation" in
			"route")
				if [[ -n "$fileOrigin" && -n "$fileTarget" ]]; then
					# A path ending in `/`, will be a directory with an index.html
					if [[ "$fileTarget" == */ ]]; then
						mkdir -p "${DIR_OUTPUT}${fileTarget}"
						templateRender "$fileOrigin" > "${DIR_OUTPUT}${fileTarget}/index.html"
					else
						mkdir -p $(dirname "${DIR_OUTPUT}/${fileTarget}")
						templateRender "$fileOrigin" > "${DIR_OUTPUT}/${fileTarget}"
					fi
				else
					log "${_IN}ERROR: missing arguments for 'template:route' command" 1 error
				fi
				;;

			*)
				# On custom commands, the {PATHS} tags are adapted for templates
				if [[ -n "${_DEFINED_CMD_MAP[$operation]}" ]]; then

					local CMD=$(printf '%s' "${_DEFINED_CMD_MAP[$operation]}" \
						| sed "s|{ORIGIN}|$DIR_TEMPLATES/$fileOrigin|g" \
						| sed "s|{BUILD}|$DIR_BUILD/$fileOrigin|g" \
						| sed "s|{TARGET}|$DIR_OUTPUT/$fileTarget|g" \
					)

					# Create target paths
					if [[ "${_DEFINED_CMD_MAP[$operation]}" =~ "{BUILD}" ]]; then
						mkdir -p $(dirname "$DIR_BUILD/$fileTarget")
					fi
					if [[ "${_DEFINED_CMD_MAP[$operation]}" =~ "{TARGET}" ]]; then
						mkdir -p $(dirname "$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget")
					fi

					log "${_IN}Executing: $CMD" 3
					eval "$CMD"
				else
					log "${_IN}ERROR: operation '$operation' not recognized" 1 error
				fi
				;;
		esac
	done
	IFS="$OLDIFS"
} #processTemplates()

templateParseIncludes() {
	declare templateFileName=$1

	((_NESTING_LEVEL++))
	if [[ "$_NESTING_LEVEL" -gt "$_NESTING_MAX" ]]; then
		log "${_IN}ERROR: max nesting level ($_NESTING_MAX) reached for template $templateFileName" 1 error
		exit 3
	fi

	# Parse template
	# TODO: search first in DIR_BUILD, if not found, don't ouput anything
	local templateFile="${DIR_TEMPLATES}/$templateFileName"
	if [[ -f "$templateFile" ]]; then
		local templateContent="$(<$templateFile)"
	else
		log "${_IN}ERROR: No template found '$templateFile'" 1 error
		return
	fi
	local directives_include=$(grep -Po "<!--$_WS*%include$_WS*:.*?-->" "$templateFile")
	local D=''

	local OLDIFS="$IFS"; IFS=$'\n'

	# Remove duplicates
	if [[ -n "$directives_include" ]]; then
		directives_include=$(printf '%s' "$directives_include" | uniq)
	fi

	for D in $directives_include; do
		local includedFileName=$(printf '%s' "$D" \
			| sed -n -e "s/<\!--$_WS*%include$_WS*:$_WS*\(.*\)$_WS*-->/\1/p" \
			| sed -e "s/$_WS*$//" )
		log "${_IN2}include: '$includedFileName'" 2

		# Parse included template for further includes
		local includedFileContent="$(templateParseIncludes ${includedFileName})"

		# Mass-replace directive with template contents
		templateContent="${templateContent//$D/$includedFileContent}"
	done
	IFS="$OLDIFS"

	((_NESTING_LEVEL--))

	printf '%s' "$templateContent"
} #templateParseIncludes()

templateRender() {
	declare templateFileName=$1

	local templateText="$(templateParseIncludes $templateFileName)"

	# Template tags must be one-liners
	local directives_set=$(printf '%s' "$templateText" \
		| grep -Po "<!--$_WS*%set$_WS*:.*?-->")
	local directives_cmd=$(printf '%s' "$templateText" \
		| grep -Po "<!--$_WS*%cmd$_WS*:.*?-->")
	local directives_setcmd=$(printf '%s' "$templateText" \
		| grep -Po "<!--$_WS*%setcmd$_WS*:.*?-->")
	local D=''

	# text comments
	#
	# <!-- // Comment -->
	#
	templateText=$(printf '%s' "$templateText" \
		| sed -e :a -re "s/<!--$_WS*\/\/.*?-->//g;/<!--\/\//N;//ba")

	local OLDIFS="$IFS"; IFS=$'\n'

	# set variables
	#
	# <!-- %set : VARIABLE=something -->
	# <!-- @VARIABLE -->
	#
	for D in $directives_set; do
		local SET=$(printf '%s' "$D" \
			| sed -n -e "s/<\!--$_WS*%set$_WS*:$_WS*\(.*\)$_WS*-->/\1/p"\
			| sed -e "s/$_WS*$//")
		local SETVAR="${SET%%=*}"
		local SETVAL="${SET#*=}"
		log "${_IN3}set: $SETVAR = $SETVAL" 3

		# Cross-platform syntax to replace including newlines
		# http://stackoverflow.com/a/1252191
		templateText=$(printf '%s' "$templateText" \
			| sed -e ":a" -e "N" -e "\$!ba" -e "s/$D\n\?//g")
		templateText=$(printf '%s' "$templateText" \
			| sed -e ":a" -e "N" -e "\$!ba" \
			-e "s/<!--$_WS*@$SETVAR$_WS*-->\n\?/$SETVAL/g")
	done

	# execute commands, render output
	#
	# <!-- %cmd : ls -l -->
	#
	for D in $directives_cmd ; do
		local CMD=$(printf '%s' "$D" \
			| sed -n -e "s/^.*<\!--$_WS*%cmd$_WS*:$_WS*\(.*\)$_WS*-->.*$/\1/p" \
			| sed -e "s/$_WS*$//")
		local CMDOUT=$(eval "$CMD")
		log "${_IN2}cmd: $CMD" 3

		local -i CMDOUT_LOGMAX=50 # log up to this number of chars
		local -i CMDOUT_LEN=$(printf "%s" "$CMDOUT" | wc -c)

		if [[ "$CMDOUT_LEN" -le "$CMDOUT_LOGMAX" ]]; then
			log "${_IN3}=: $CMDOUT" 3
		else
			log "${_IN3}=: $(printf '%s' "$CMDOUT" | tr '\n' ' ' \
				| head -c$CMDOUT_LOGMAX) (...) + $(($CMDOUT_LEN-$CMDOUT_LOGMAX)) chars" 3
		fi

		# Substitute the directive in the template with the command output
		# http://stackoverflow.com/a/40749641/940200
		templateText=$(awk -v repl="$CMDOUT" 'FNR==NR {
				a = a $0; next
			}
			n = index($0, a) {
				$0 = substr($0, 1, n-1) repl substr($0, n+length(a))
			} 1' <(printf '%s\n' "$D") <(printf '%s' "$templateText")
		)
	done

	# set variables to commands output
	#
	# <!-- %setcmd : VARIABLE=ls -l -->
	# <!-- @VARIABLE -->
	#
	for D in $directives_setcmd; do
		local SETCMD=$(printf '%s' "$D" \
			| sed -n -e "s/^.*<\!--$_WS*%setcmd$_WS*:$_WS*\(.*\)$_WS*-->.*$/\1/p" \
			| sed -e "s/$_WS*$//")
		local SETCMDVAR="${SETCMD%%=*}"
		local SETCMDVAL="${SETCMD#*=}"
		local SETCMDOUT=$(eval "$SETCMDVAL")
		log "${_IN2}setcmd: $SETCMDVAR = $SETCMDVAL" 3

		# Delete the directive from the template
		templateText=$(awk -v 'FNR==NR {
				a = a $0; next
			}
			n = index($0, a) {
				$0 = substr($0, 1, n-1) substr($0, n+length(a))
			} 1' <(printf '%s\n' "$D") <(printf '%s' "$templateText")
		)
		# Replace all the set variables with the command output
		templateText=$(printf '%s' "$templateText" \
			| sed -e ":a" -e "N" -e "\$!ba" \
			-e "s/<!--$_WS*@$SETCMDVAR$_WS*-->\n\?/$SETCMDOUT/g")
	done

	IFS="$OLDIFS"

	log "" 2

	printf "%s" "$templateText"
} #templateRender()

__checkCompatibility() {
	local bashBigVersion=$(echo "$BASH_VERSION" | cut -d'.' -f1)
	if [[ "$bashBigVersion" -lt 4 ]]; then
		printf '%s\n' "Bash version 4 needed. Detected version is $BASH_VERSION"
		exit 6
	fi
}

__setupDebugging() {
	set -o errexit
	[[ -n "$WEBERA_DEBUG" ]] && set -o xtrace && \
	export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
}

__printVars() { printf '%s\n' "$__VARS_WEBERA"; }

[[ "$0" == "$BASH_SOURCE" ]] && main "$@" || true # Run if not sourced
