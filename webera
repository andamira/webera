#!/usr/bin/env bash
#
# webera
# a handy shellscript for static website generation
#
# Repository: https://github.com/andamira/webera
# Author: Jos√© Luis Cruz
# Version: 0.1.54
# License: MIT
#
# Dependencies:
#     bash 4, grep -P, sed, awk, coreutils
##

#-------------------------------------------------------------------------------
#   main
#
# Arguments:
#   $@ - all the arguments passed to the script
#
main() {

	## INTERNAL DATA (A)

	__checkCompatibility
	local -ir __WEBERA_TIME_STAMP="$(date '+%s%3N')" # [INC02]
	__setupDebugging

	declare __VARS_WEBERA __VARS_BEFORE __VARS_AFTER
	__VARS_WEBERA="" # = will contain a list of all the settings (-_)
	__VARS_BEFORE=$(set -o posix ; set | awk -F= '{print $1"="}' )


	## CONFIGURABLE SETTINGS
	#
	# NOTE: Variables starting with an underscore can't be configured
	# from a file, but they can be configured using script arguments.

	# Paths
	local DIR_TEMPLATES=tem
	local DIR_RESOURCES=res
	local DIR_BUILD=build
	local DIR_OUTPUT=out
	local _CONFIG_FILE=.weberarc
	local _CONFIG_STRING=""

	# Web Browser
	local WEB_BROWSER="firefox"
	local SERVER_TYPE="python"
	local -i SERVER_PORT=8192
	local SERVER_HOST="localhost"
	local SERVER_START=""
	local SERVER_STOP=""

	# Log
	local LOG_FILE=log.txt
	local OPTION_LOG_CLEAR=false
	local -i OPTION_LOG_LEVEL=0 # 0 = no log | 1 | 2 | 3

	# Delete output & build directories
	local OPTION_DELETE_DIR_OUTPUT=true
	local OPTION_DELETE_DIR_BUILD=true

	# Misc
	local -i NESTING_MAX=8


	## INTERNAL SETTINGS
	#
	# NOTE: The following variables can't be externally configured

	local _OPERATIONAL=false

	local _DO_PROCESS_TEMPLATES=false
	local _DO_PROCESS_RESOURCES=false
	local _DO_PREVIEW_IN_BROWSER=false

	local _DO_GENERATE_CONFIG_FILE=false # has it been requested to generate? (-n)

	local -i _NESTING_LEVEL=0

	local _CONFIG_JOINT="" # where to save all the configurations
	local _PRELOG="" # where log is saved before there's a logfile

	declare -A _ARG_OPTIONS
	declare -A _DEFINED_CMD_MAP

	## INTERNAL DATA (B)

	local -r _DATE="$(date '+%Y-%m-%d %H:%M:%S' \
		-d @"${__WEBERA_TIME_STAMP:0:10}")" # [INC03]

	# log indentation and formatting
	declare -r _IN="  " _IN2="    " _IN3="      "
	local -r _HEADING='------------------------------------------------------'

	# reusable regexp patterns
	local -r _WS="[[:space:]]" # whitespace
	local -r _SED_TRIM_WS="s/^$_WS*//;s/$_WS*$//"
	local -r _SED_DEL_COMMENTS="/^$_WS*#.*/d" # starting in #
	local -r _SED_DEL_EMPTYLINES="/^$_WS*$/d"
	local -r _SED_JOIN_SPLITLINES=':x; /\\$/ { N; s/\\\n//; tx }' # ending in \

	# compile the list of the default settings
	__VARS_AFTER="$(set -o posix ; set | sed '/^'\''/d' )"
	printf -v __VARS_WEBERA '%s' "$(grep -vFf \
		<(printf '%s' "$__VARS_BEFORE") <(printf '%s' "$__VARS_AFTER") \
		| sed 's/^/[vdef]::/' )"
	unset __VARS_BEFORE; unset __VARS_AFTER;
	local __DO_PRINT_VARS=false


	## MAIN PROCESS

	log 1 "\n===============[$_DATE]==============@\n"

	parseArguments "$@"

	[[ "$_CONFIG_FILE" != "/etc/weberarc" ]] && \
		readConfig file "/etc/weberarc"
	[[ "$_CONFIG_FILE" != "$HOME/.weberarc" ]] && \
		readConfig file "$HOME/.weberarc"
	readConfig file "$_CONFIG_FILE"
	readConfig string '_CONFIG_STRING'

	configureSettings

	if [[ "$__DO_PRINT_VARS" == true ]]; then __varsPrint; return "$?"; fi

	setupLog

	deleteDirectories

	readConfigCommands

	[[ "$_DO_PROCESS_RESOURCES" == true ]] && processResources
	[[ "$_DO_PROCESS_TEMPLATES" == true ]] && processTemplates

	log "Elapsed time: $(printf '%16s' "$(__timeElapsed true)")"

	[[ "$_DO_PREVIEW_IN_BROWSER" == true ]] && previewWebsite
	exit 0

} #main()


#-------------------------------------------------------------------------------
#   usage
#
#   Displays Usage information.
#
# Arguments:
#   $1 - (optional) error code
# Returns:
#   $1 - (exit) the received error code
# Called by:
#   parseArguments()
#   configureSettings()
#
usage() {
	cat -- <<-ENDUSAGE
	Usage: ./webera -[trwn] [optional flags]

	MAIN FLAGS

	  -t              process the templates
	  -r              process the resources
	  -w              preview in web browser

	  -n              generate a new configuration file

	OPTIONAL          ... (DEFAULT)

	  -F <FILE>       indicate the configuration file ($_CONFIG_FILE)
	  -C <STRING>     pass the configuration as a string ($_CONFIG_STRING)

	  -T <DIR>        indicate the templates directory ($DIR_TEMPLATES)
	  -R <DIR>        indicate the resources directory ($DIR_RESOURCES)
	  -O <DIR>        indicate the output directory ($DIR_OUTPUT)
	  -B <DIR>        indicate the build directory ($DIR_BUILD)

	  -d              switch deleting the output dir (delete=$OPTION_DELETE_DIR_OUTPUT)
	  -c              switch clearing the log file (clear=$OPTION_LOG_CLEAR)

	  -L <NUMBER>     log level [0=none|1|2|3] ($OPTION_LOG_LEVEL)
	  -G <FILE>       log file ($LOG_FILE)

	  -W <BIN>        web browser binary ($WEB_BROWSER)
	  -S <TYPE>       server type [none|php|python|custom] ($SERVER_TYPE)
	  -H <DOMAIN>     server host ($SERVER_HOST)
	  -P <NUMBER>     port number ($SERVER_PORT)
	ENDUSAGE
	[[ -n "$1" ]] && exit "$1"

} #usage()


#-------------------------------------------------------------------------------
#   parseArguments
#
#   Parses the arguments received by the script and sets the pertinent options.
#
# Arguments:
#   $@ - all the arguments passed to the script
# Returns:
#    1 - (exit via usage) when the argument is unknown
#
# Called by:
#   main()
#
parseArguments() {
	local OPTIND option

	while getopts ':trwnF:C:T:R:O:B:dcL:G:W:S:H:P:_h:' option; do
		case "$option" in
			t) _OPERATIONAL=true; _ARG_OPTIONS[_DO_PROCESS_TEMPLATES]=true ;;
			r) _OPERATIONAL=true; _ARG_OPTIONS[_DO_PROCESS_RESOURCES]=true ;;
			w) _OPERATIONAL=true; _ARG_OPTIONS[_DO_PREVIEW_IN_BROWSER]=true ;;

			n) _ARG_OPTIONS[_DO_GENERATE_CONFIG_FILE]=true
				_OPERATIONAL=true; _DO_GENERATE_CONFIG_FILE=true; ;;

			F) _CONFIG_FILE="$OPTARG"
				_ARG_OPTIONS[_CONFIG_FILE]="$OPTARG"
				_CONFIG_FILE_EXPLICIT=true;
				;;
			C) _CONFIG_STRING="$OPTARG" ;;

			# The following options can also be defined in $_CONFIG_FILE, but
			# passing them as arguments to the script has a higher priority.

			T) _ARG_OPTIONS[DIR_TEMPLATES]="$OPTARG" ;;
			R) _ARG_OPTIONS[DIR_RESOURCES]="$OPTARG" ;;
			O) _ARG_OPTIONS[DIR_OUTPUT]="$OPTARG" ;;
			B) _ARG_OPTIONS[DIR_BUILD]="$OPTARG" ;;

			# These flags switches the default boolean value,
			# (without checking first the values in file config).
			d) if [[ "$OPTION_DELETE_DIR_OUTPUT" == true ]]; then
					_ARG_OPTIONS[OPTION_DELETE_DIR_OUTPUT]=false
				else
					_ARG_OPTIONS[OPTION_DELETE_DIR_OUTPUT]=true
				fi
				;;
			c) if [[ "$OPTION_LOG_CLEAR" == true ]]; then
					_ARG_OPTIONS[OPTION_LOG_CLEAR]=false
				else
					_ARG_OPTIONS[OPTION_LOG_CLEAR]=true
				fi
				;;

			L) _ARG_OPTIONS[OPTION_LOG_LEVEL]="$OPTARG" ;;
			G) _ARG_OPTIONS[LOG_FILE]="$OPTARG" ;;

			W) _ARG_OPTIONS[WEB_BROWSER]="$OPTARG" ;;
			S) _ARG_OPTIONS[SERVER_TYPE]="$OPTARG" ;;
			H) _ARG_OPTIONS[SERVER_HOST]="$OPTARG" ;;
			P) _ARG_OPTIONS[SERVER_PORT]="$OPTARG" ;;

			_) _OPERATIONAL=true; __DO_PRINT_VARS=true ;; # hidden argument

			h) usage 0 ;;
			*) usage 1 ;; # unknown argument
		esac
	done
	shift $((OPTIND-1))

} #parseArguments()


#-------------------------------------------------------------------------------
#   setupLog
#
#   Prepares the log file and writes all the logs previously saved in _PRELOG.
#
# Called by:
#   main()
#
setupLog() {
	local parsedPrelog

	if [[ "$OPTION_LOG_CLEAR" == true ]]; then
		log 3 warn "\nWarning: deleting previous log file '$LOG_FILE'"
		rm -- "$LOG_FILE" 2>/dev/null;
	fi

	# Write the pre-saved log to the file
	#
	# 1. filter out the lines with greater than current log level
	# 2. leave only the log message, discard the rest.
	# 3. bring back the newlines
	# 4. put the log level in the date header
	#
	# shellcheck disable=SC2059
	parsedPrelog=$(printf "$_PRELOG" \
		| awk -v logLevel=$OPTION_LOG_LEVEL -F '|' '$1<=logLevel' \
		| cut -d'|' -f3- \
		| tr '\a' '\n' \
		| sed "s/====@$/====$OPTION_LOG_LEVEL/" \
	)
	_PRELOG=false

	[[ -n "$parsedPrelog" ]] && log "$parsedPrelog"

} #setupLog()


#-------------------------------------------------------------------------------
#   log
#
#   prints a message to the log file. Errors and warnings also to STDERR.
#
# Arguments:
#   $1  - (optional) logLevelNeeded
#   $2  - (optional) logType [warn|error]
#   $3+ - log message
#
# shellcheck disable=SC2059
log() {
	local logLevelNeeded="$1" # First (optional) parameter...
	declare -ir logLevelMin=1 logLevelMax=3

	declare logMessage msg1line

	# must be an integer number
	if [[ "$logLevelNeeded" =~ ^[0-9]+$ ]]; then
		if [[ "$logLevelNeeded" -lt "$logLevelMin" ]]; then
			LOG_LEVEL="$logLevelMin"
		elif [[ "$logLevelNeeded" -gt "$logLevelMax" ]]; then
			LOG_LEVEL="$logLevelMax"
		else
			LOG_LEVEL="$logLevelNeeded"
		fi
		shift # prepare next positional parameter

	else # if not a number, use defaults
		logLevelNeeded="$logLevelMin"
		LOG_LEVEL="$logLevelNeeded"
	fi

	local logType="$1" # Second (optional) parameter...

	# must be the type
	case "$logType" in
		error|warn)
			shift # prepare next positional parameter
			;;
		*) logType="" ;;
	esac

	local IFSbkp="$IFS"; IFS=$''
	logMessage="$*" # The rest of parameters must be the log message
	IFS="$IFSbkp"

	if [[ "$_PRELOG" == false ]]; then
		if [[ "$LOG_LEVEL" -le "$OPTION_LOG_LEVEL" ]]; then
			printf '%s\n' "$logMessage" >> "$LOG_FILE"
		fi
	else
		# Pre-save this log message as a single line
		#
		# 1. replace the newlines with a BEL
		# 2. put the log level and type at the beginning
		msg_1line=$(printf "$logMessage" | tr '\n' '\a') || true
		_PRELOG+="\n$logLevelNeeded|$logType|$msg_1line"
	fi

	# Print errors and warnings to stderr
	if [[ "$logType" == "error" || "$logType" == "warn" ]]; then
		printf "$logMessage" | tr -d '\n' | awk '{ print }' - >&2
	fi

} # log()


#-------------------------------------------------------------------------------
#   previewWebsite
#
#   Prepares the server commands, for previewing in the browser.
#
# Returns:
#   5 - (exit) Server type not recognized
# Called by:
#   main() - when the script received the `-r` flag
#
previewWebsite() {
	local cmdBrowser

	# shellcheck disable=SC2016
	case "$SERVER_TYPE" in
		python)
			SERVER_START='pushd "$DIR_OUTPUT"; python -m SimpleHTTPServer $SERVER_PORT'
			SERVER_STOP='kill $(pgrep -f "python -m SimpleHTTPServer")'
			;;
		php)
			SERVER_START='php -S "$SERVER_HOST:$SERVER_PORT" -t "$DIR_OUTPUT"'
			SERVER_STOP='kill $(pgrep -f "php -S $SERVER_HOST")'
			;;
		none) # useful when not using `dir/index.html` structure
			SERVER_START=""
			SERVER_STOP=""
			;;
		custom) # for when a server is already running, or custom SERVER_START
			;;
		*)
			log 2 error "ERROR: Not recognized SERVER_TYPE='$SERVER_TYPE'"
			exit 5
			;;
	esac

	printf 'Loading website in "%s"...\n' "$WEB_BROWSER"

	if [[ "$SERVER_TYPE" == "none" ]]; then
		cmdBrowser="$WEB_BROWSER file://$(readlink -f $DIR_OUTPUT) &"
	else
		cmdBrowser="$WEB_BROWSER http://$SERVER_HOST:$SERVER_PORT &"
	fi

	sleep 1s && eval "$cmdBrowser" >&2 2>/dev/null
	if [[ -n "$SERVER_START" ]]; then
		printf '(Use CTRL+C to stop the "%s" web server)\n' \
			"$SERVER_TYPE"
		printf 'SERVER_START=%s' "$SERVER_START"
		eval "$SERVER_STOP >&2 2>/dev/null"; eval "$SERVER_START"
	fi

} #previewWebsite()


#-------------------------------------------------------------------------------
#   deleteDirectories
#
#   Deletes the build/ and output directories if there's going to be operations.
#
# Called by:
#   main()
#
deleteDirectories() {
	[[ "$OPTION_DELETE_DIR_BUILD" == true ]] && rm -rf -- "$DIR_BUILD" 2>/dev/null

	if [[ "$OPTION_DELETE_DIR_OUTPUT" == true ]] && \
		[[ $_DO_PROCESS_RESOURCES == true \
		|| $_DO_PROCESS_TEMPLATES == true ]]; then
		rm -rf -- "$DIR_OUTPUT" 2>/dev/null
	fi

} #deleteDirectories()


#-------------------------------------------------------------------------------
#   readConfig
#
#   Reads some configuration from a file or a string,
#   and joins it together to a common source.
#
# Arguments:
#   $1 - $configType [file|string]
#   $2 - $configPointer can be either the file name or the variable name
# Returns:
#   10 - (exit) unknown config type
# Called by:
#   main()
#
readConfig() {
	declare configType="$1" configPointer="$2"
	declare readConfig configLine

	if [[ "$configType" == "string" ]]; then
		if [[ -n "${!configPointer}" ]]; then # string is not empty
			log 3 "Reading settings passed as an argument."
			readConfig="$(printf '%s' "${!configPointer}" \
				| sed -e "$_SED_TRIM_WS" \
				| sed -e "$_SED_DEL_COMMENTS" -e "$_SED_DEL_EMPTYLINES" \
				| sed -e "$_SED_JOIN_SPLITLINES" \
			)"$'\n'
			_CONFIG_JOINT+="$readConfig"
			__varsPush strn "" "$readConfig"
		fi

	elif [[ "$configType" == "file" ]]; then
		if [[ -f "$configPointer" ]]; then # file exists

			if [[ "$_DO_GENERATE_CONFIG_FILE" == true ]]; then
				log 2 warn "Warning: automatic override of an existing " \
					"local config file ('$configPointer') is not permitted."
			else
				log 3 "Reading settings from file '$configPointer'"
				readConfig="$(sed -e "$_SED_TRIM_WS" "$configPointer" \
					| sed -e "$_SED_DEL_COMMENTS" -e "$_SED_DEL_EMPTYLINES" \
					| sed -e "$_SED_JOIN_SPLITLINES" \
				)"$'\n'
				_CONFIG_JOINT+="$readConfig" # append
				__varsPush file "$configPointer" "$readConfig"
			fi

		else # config file doesn't exist
			# it's the config file of the project
			if [[ "$configPointer" == "$_CONFIG_FILE" ]]; then
				 # stop if printing debug info
				[[ "$__DO_PRINT_VARS" == true ]] && return 0

				if [[ "$_DO_GENERATE_CONFIG_FILE" == true ]]; then
					generateConfig
				else
					log 3 warn "Warning: project's config file " \
						"'$_CONFIG_FILE' doesn't exist."
				fi
			fi
		fi
	else
		log error "Error: unknown config type"
		exit 10
	fi

} #readConfig()


#-------------------------------------------------------------------------------
#   configureSettings
#
#   Parses the configuration settings and overrides them with:
#   1) the joint configuration 2) the passed arguments.
#
# Returns:
#    1 - (exit via usage) no main operatives flags used
# Called by:
#   main()
#
configureSettings() {
	declare settingsList setting arg settingName settingValue settingPrevious

	settingsList="$(printf '%s' "$_CONFIG_JOINT" | grep "^$_WS*config$_WS*:" )"

	if [[ -n "$settingsList" ]]; then
		log 1 "\nConfiguring settings...\n$_HEADING"

		local IFSbkp="$IFS"; IFS=$'\n'
		for setting in $settingsList; do
			settingName=$(printf '%s' "$setting" | cut -d':' -f2 \
				| sed -e "$_SED_TRIM_WS")
			settingValue=$(printf '%s' "$setting" | cut -d':' -f3- \
				| sed -e "$_SED_TRIM_WS")

			[[ -n "${!settingName}" ]] &&
				settingPrevious="(previous=${!settingName})"
			log 1 "${_IN}setting: $settingName=$settingValue " \
				"$settingPrevious"

			[[ "$setting" != _* ]] && # read (only public) settings from file
				printf -v "$settingName" '%s' "$settingValue"
		done
		IFS="$IFSbkp"
	fi

	# Override the settings with the parsed arguments
	for arg in "${!_ARG_OPTIONS[@]}"; do
		printf -v "$arg" '%s' "${_ARG_OPTIONS[$arg]}"
		printf -v __VARS_WEBERA '%s' \
			"$__VARS_WEBERA"$'\n'"[args]::$arg=${_ARG_OPTIONS[$arg]}"
	done

	if [[ "$_OPERATIONAL" == false ]]; then
		log 1 error "You must use at least one MAIN FLAG!\n\n"
		usage 1
	fi

} #configureSettings()


#-------------------------------------------------------------------------------
#   generateConfig
#
#   Generates a config file, writing down the settings modified via arguments.
#
# Called by:
#   main() - when the script received the `-n` flag
#
generateConfig() {
	local configLines=()
	declare opt line

	for opt in "${!_ARG_OPTIONS[@]}"; do
		[[ "$opt" != _* ]] && # write (only public) vars to config file
			configLines+=("config : $opt : ${_ARG_OPTIONS[$opt]}")
	done

	touch "$_CONFIG_FILE"
	for line in "${configLines[@]}"; do
		printf '%s\n' "$line" >> "$_CONFIG_FILE"
	done

} #generateConfig()


#-------------------------------------------------------------------------------
#   readConfigCommands
#
#   Reads the configuration commands for processing templates and resources.
#
# Called by:
#   main()
#
readConfigCommands() {
	declare commandList C commandNum commandName commandAction

	commandList="$(printf '%s' "$_CONFIG_JOINT" | grep "^$_WS*command$_WS*:" )"

	if [[ -n "$commandList" ]]; then
		commandNum=$(printf '%s\n' "$commandList" | wc -l )
		log 1 "\nParsing commands...\n$_HEADING"
		log 1 "${_IN}Found $commandNum defined command:"
	else return 0; fi

	local IFSbkp="$IFS"; IFS=$'\n'
	for C in $commandList; do
		commandName=$(printf '%s' "$C" | cut -d':' -f2 \
			| sed -e "$_SED_TRIM_WS" )
		commandAction=$(printf '%s' "$C" | cut -d':' -f3- \
			| sed -e "$_SED_TRIM_WS" )

		_DEFINED_CMD_MAP["$commandName"]="$commandAction"

		log 2 "${_IN}$commandName='$commandAction'"
	done
	IFS="$IFSbkp"

} #readConfigCommands()


#-------------------------------------------------------------------------------
#   processResources
#
#   Parses the configuration and executes the resource operations.
#
# Returns:
#   8 - no resources directory found
# Called by:
#   main() - when the script received the `-r` flag
#
processResources() {
	declare resourceOpList resourceOpNum resourceOp
	declare operation fileOrigin fileTarget command

	log 1 "\nProcessing resources...\n$_HEADING"

	if [[ ! -d "$DIR_RESOURCES" ]]; then
		log 1 error "No resources dir '$DIR_RESOURCES' found."
		return 8
	fi

	resourceOpList="$(printf '%s' "$_CONFIG_JOINT" \
		| grep "^$_WS*resource$_WS*:" )"
	resourceOpNum=$(printf '%s\n' "$resourceOpList" \
		| sed "$_SED_DEL_EMPTYLINES" | wc -l )
	log 1 "${_IN}Found $resourceOpNum operations on resources:"

	local IFSbkp="$IFS"; IFS=$'\n'
	for resourceOp in $resourceOpList; do

		operation=$(printf '%s' "$resourceOp" | cut -d':' -f2 \
			| sed -e "$_SED_TRIM_WS" )
		fileOrigin=$(printf '%s' "$resourceOp" | cut -d':' -f3 \
			| sed -e "$_SED_TRIM_WS" )
		fileTarget=$(printf '%s' "$resourceOp" | cut -d':' -f4 \
			| sed -e "$_SED_TRIM_WS" )

		log 1 "${_IN}$operation: $fileOrigin > $fileTarget"

		if [[ ! -e "$DIR_RESOURCES/$fileOrigin" ]]; then
			log 1 error "${_IN}ERROR: '$fileOrigin' don't exist"
			continue # XXX do break instead?
		fi

		case "$operation" in
			"copy")
				mkdir -p -- "$DIR_OUTPUT/$DIR_RESOURCES/$(dirname "$fileTarget")"
				cp -r -- "$DIR_RESOURCES/$fileOrigin" \
					"$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget"
				;;
			*)
				# On custom commands, {PATHS} tags are adapted for resources
				if [[ -n "${_DEFINED_CMD_MAP[$operation]}" ]]; then

					command=$(printf '%s' "${_DEFINED_CMD_MAP[$operation]}" \
						| sed "s|{ORIGIN}|$DIR_RESOURCES/$fileOrigin|g" \
						| sed "s|{BUILD}|$DIR_BUILD/$fileOrigin|g" \
						| sed "s|{TARGET}|$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget|g")

					# Create target paths
					if [[ "${_DEFINED_CMD_MAP[$operation]}" == *"{BUILD}"* ]]; then
						mkdir -p -- "$(dirname "$DIR_BUILD/$fileTarget")"
					fi
					if [[ "${_DEFINED_CMD_MAP[$operation]}" == *"{TARGET}"* ]]; then
						mkdir -p -- "$(dirname \
							"$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget")"
					fi

					log 3 "${_IN}Executing: $command"
					eval "$command"
				else
					log 1 error \
						"${_IN}ERROR: operation '$operation' not recognized"
				fi
				;;
		esac
	done
	IFS="$IFSbkp"

} #processResources()


#-------------------------------------------------------------------------------
#   processTemplates
#
#   Parses the configuration and executes the template operations.
#
# Returns:
#  9 - no templates directory found
# Called by:
#   main() - when the script received the `-t` flag
#
processTemplates() {
	declare templateOpList templateOpNum templateOp
	declare operation fileOrigin fileTarget command

	log 1 "\nProcessing templates...\n$_HEADING"

	if [[ ! -d "$DIR_TEMPLATES" ]]; then
		log 1 error "No templates dir '$DIR_TEMPLATES' found."
		return 9
	fi

	templateOpList="$(printf '%s' "$_CONFIG_JOINT" \
		| grep "^$_WS*template$_WS*:" )"

	templateOpNum=$(printf '%s\n' "$templateOpList" \
		| sed "$_SED_DEL_EMPTYLINES" | wc -l )
	log 1 "${_IN}Found $templateOpNum operations on templates:"

	local IFSbkp="$IFS"; IFS=$'\n'
	for templateOp in $templateOpList; do
		operation=$(printf '%s' "$templateOp" | cut -d':' -f2 \
			| sed -e "$_SED_TRIM_WS" )
		fileOrigin=$(printf '%s'  "$templateOp" | cut -d':' -f3 \
			| sed -e "$_SED_TRIM_WS" )
		fileTarget=$(printf '%s' "$templateOp" | cut -d':' -f4 \
			| sed -e "$_SED_TRIM_WS" )

		log 1 "${_IN}$operation: $fileOrigin > $fileTarget"

		case "$operation" in
			"route")
				if [[ -n "$fileOrigin" && -n "$fileTarget" ]]; then
					# A path ending in `/`, will be a dir_name/index.html
					if [[ "$fileTarget" == */ ]]; then
						mkdir -p -- "${DIR_OUTPUT}${fileTarget}"
						templateRender "$fileOrigin" > \
							"${DIR_OUTPUT}${fileTarget}/index.html"
					else
						mkdir -p -- "$(dirname "${DIR_OUTPUT}/${fileTarget}")"
						templateRender "$fileOrigin" > \
							"${DIR_OUTPUT}/${fileTarget}"
					fi
				else
					log 1 error "${_IN}ERROR: missing arguments for" \
						"'template:route' operation"
				fi
				;;

			*)
				# On custom commands, the {PATHS} tags are adapted for templates
				if [[ -n "${_DEFINED_CMD_MAP[$operation]}" ]]; then

					command=$(printf '%s' "${_DEFINED_CMD_MAP[$operation]}" \
						| sed "s|{ORIGIN}|$DIR_TEMPLATES/$fileOrigin|g" \
						| sed "s|{BUILD}|$DIR_BUILD/$fileOrigin|g" \
						| sed "s|{TARGET}|$DIR_OUTPUT/$fileTarget|g" \
					)

					# Create target paths
					if [[ "${_DEFINED_CMD_MAP[$operation]}" == *"{BUILD}"* ]]; then
						mkdir -p -- "$(dirname "$DIR_BUILD/$fileTarget")"
					fi
					if [[ "${_DEFINED_CMD_MAP[$operation]}" == *"{TARGET}"* ]]; then
						mkdir -p -- "$(dirname "$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget")"
					fi

					log 3 "${_IN}Executing: $command"
					eval "$command"
				else
					log 1 error \
						"${_IN}ERROR: operation '$operation' not recognized"
				fi
				;;
		esac
	done
	IFS="$IFSbkp"

} #processTemplates()


#-------------------------------------------------------------------------------
#   templateParseIncludes
#
#   Recursively parses a template for include directives, and then
#   joins all the parts together in a single template.
#
# Arguments:
#  $1 - templateFileName
# Returns:
#   3 - (exit) Maximum nesting level overflow
#   7 - No template found
# Called by:
#   templateRender()
#
templateParseIncludes() {
	declare templateFileName=$1
	declare templateContent directive directives_include incFileName incFileContent

	((_NESTING_LEVEL++))
	if [[ "$_NESTING_LEVEL" -gt "$NESTING_MAX" ]]; then
		log 1 error "${_IN}ERROR: max nesting level ($NESTING_MAX)" \
			"reached for template $templateFileName"
		exit 3
	fi

	# Parse template
	local templateFile="${DIR_TEMPLATES}/$templateFileName"
	if [[ -f "$templateFile" ]]; then
		templateContent="$(<"$templateFile")"
	else
		log 1 error "${_IN}ERROR: No template found '$templateFile'"
		return 7
	fi
	directives_include=$(grep -Po "<!--$_WS*%include$_WS*:.*?-->" \
		"$templateFile") # [INC01]

	local IFSbkp="$IFS"; IFS=$'\n'

	# Remove duplicates
	if [[ -n "$directives_include" ]]; then
		directives_include=$(printf '%s' "$directives_include" | uniq)
	fi

	for directive in $directives_include; do
		incFileName=$(printf '%s' "$directive" \
			| sed -n -e "s/<\!--$_WS*%include$_WS*:$_WS*\(.*\)$_WS*-->/\1/p" \
			| sed -e "s/$_WS*$//" )
		log 2 "${_IN2}include: '$incFileName'"

		# Parse included template for further includes
		incFileContent="$(templateParseIncludes "${incFileName}")"

		# Mass-replace directive with template contents
		templateContent="${templateContent//$directive/$incFileContent}"
	done
	IFS="$IFSbkp"

	((_NESTING_LEVEL--))

	printf '%s' "$templateContent"

} #templateParseIncludes()


#-------------------------------------------------------------------------------
#   templateRender
#
#   Parses the template, processes the directives and renders the html file.
#
# Arguments:
#   $1 - templateFileName
# Called by:
#   processTemplates() - when parsing the 'route' command
#
templateRender() {
	declare templateFileName=$1

	declare templateText directives_set directives_cmd directives_setcmd
	declare directive setVarVal setVar setValue cmd cmdOutput
	declare setCmdVar setCmdValue setCmd setCmdOutput
	declare -i cmdOutputLength maxOutputLength=50 # in characters

	templateText="$(templateParseIncludes "$templateFileName")"

	# Template tags must be one-liners
	directives_set=$(printf '%s' "$templateText" \
		| grep -Po "<!--$_WS*%set$_WS*:.*?-->") # [INC01]
	directives_cmd=$(printf '%s' "$templateText" \
		| grep -Po "<!--$_WS*%cmd$_WS*:.*?-->") # [INC01]
	directives_setcmd=$(printf '%s' "$templateText" \
		| grep -Po "<!--$_WS*%setcmd$_WS*:.*?-->") # [INC01]

	# text comments
	#
	# <!-- // Comment -->
	#
	templateText=$(printf '%s' "$templateText" \
		| sed -e :a -re "s/<!--$_WS*\/\/.*?-->//g;/<!--\/\//N;//ba")

	local IFSbkp="$IFS"; IFS=$'\n'

	# set variables
	#
	# <!-- %set : VARIABLE=something -->
	# <!-- @VARIABLE -->
	#
	for directive in $directives_set; do
		setVarVal=$(printf '%s' "$directive" \
			| sed -n -e "s/<\!--$_WS*%set$_WS*:$_WS*\(.*\)$_WS*-->/\1/p"\
			| sed -e "s/$_WS*$//")
		setVar="${setVarVal%%=*}"
		setValue="${setVarVal#*=}"
		log 3 "${_IN3}set: $setVar = $setValue"

		# Cross-platform syntax to replace including newlines
		# http://stackoverflow.com/a/1252191
		templateText=$(printf '%s' "$templateText" \
			| sed -e ":a" -e "N" -e "\$!ba" -e "s/$directive\n\?//g")
		templateText=$(printf '%s' "$templateText" \
			| sed -e ":a" -e "N" -e "\$!ba" \
			-e "s/<!--$_WS*@$setVar$_WS*-->\n\?/$setValue/g")
	done

	# execute commands, render output
	#
	# <!-- %cmd : ls -l -->
	#
	for directive in $directives_cmd ; do
		cmd=$(printf '%s' "$directive" \
			| sed -n -e "s/^.*<\!--$_WS*%cmd$_WS*:$_WS*\(.*\)$_WS*-->.*$/\1/p" \
			| sed -e "s/$_WS*$//")
		cmdOutput=$(eval "$cmd")
		log 3 "${_IN2}cmd: $cmd"

		cmdOutputLength=$(printf "%s" "$cmdOutput" | wc -c)

		if [[ "$cmdOutputLength" -le "$maxOutputLength" ]]; then
			log 3 "${_IN3}=: $cmdOutput"
		else
			log 3 "${_IN3}=: $(printf '%s' "$cmdOutput" | tr '\n' ' ' \
				| head -c$maxOutputLength) (...) +" \
				"$((cmdOutputLength-maxOutputLength)) chars"
		fi

		# Substitute the directive in the template with the command output
		# http://stackoverflow.com/a/40749641/940200
		templateText=$(awk -v repl="$cmdOutput" 'FNR==NR {
				a = a $0; next
			}
			n = index($0, a) {
				$0 = substr($0, 1, n-1) repl substr($0, n+length(a))
			} 1' <(printf '%s\n' "$directive") <(printf '%s' "$templateText")
		)
	done

	# set variables to commands output
	#
	# <!-- %setcmd : VARIABLE=ls -l -->
	# <!-- @VARIABLE -->
	#
	for directive in $directives_setcmd; do
		setCmd=$(printf '%s' "$directive" \
			| sed -n -e "s/^.*<\!--$_WS*%setcmd$_WS*:$_WS*\(.*\)$_WS*-->.*$/\1/p" \
			| sed -e "s/$_WS*$//")
		setCmdVar="${setCmd%%=*}"
		setCmdValue="${setCmd#*=}"
		setCmdOutput=$(eval "$setCmdValue")
		log 3 "${_IN2}setcmd: $setCmdVar = $setCmdValue"

		# Delete the directive from the template
		templateText=$(awk -v 'FNR==NR {
				a = a $0; next
			}
			n = index($0, a) {
				$0 = substr($0, 1, n-1) substr($0, n+length(a))
			} 1' <(printf '%s\n' "$directive") <(printf '%s' "$templateText")
		)
		# Replace all the set variables with the command output
		templateText=$(printf '%s' "$templateText" \
			| sed -e ":a" -e "N" -e "\$!ba" \
			-e "s/<!--$_WS*@$setCmdVar$_WS*-->\n\?/$setCmdOutput/g")
	done

	IFS="$IFSbkp"

	log 3

	printf "%s" "$templateText"

} #templateRender()


#-------------------------------------------------------------------------------
#   __checkCompatibility
#
#   Checks for dependencies and displays pertinent information.
#
# Returns:
#   6 - (exit) Bash version is too old
# Called by:
#   main()
#
__checkCompatibility() {
	local bashBigVersion

	bashBigVersion=$(echo "$BASH_VERSION" | cut -d'.' -f1)
	if [[ "$bashBigVersion" -lt 4 ]]; then
		printf '%s\n' "Bash version 4 needed. Detected version is $BASH_VERSION"
		exit 6
	fi
}


#-------------------------------------------------------------------------------
#   __setupDebugging
#
#   Enables xtrace if WEBERA_DEBUG has been defined, and sets a nice formatting.
#
# Called by:
#   main()
#
# shellcheck disable=SC2016
__setupDebugging() {
	local ps4_date='[$(($(date "+%s%3N")-__WEBERA_TIME_STAMP))ms]' # [INC02]
	local ps4_line='L$LINENO'
	local ps4_func='${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

	[[ -n "$WEBERA_DEBUG" ]] && set -o xtrace && \
		export PS4="+ $ps4_date $ps4_line $ps4_func"
}


#-------------------------------------------------------------------------------
#   __varsPrint
#
#   Prints all the script "global" settings and data, public and private.
#
__varsPrint() { printf '%s\n' "$__VARS_WEBERA"; }


#-------------------------------------------------------------------------------
#   __varsPush
#
#   Parses configuration, extracts the config variables and appends them
#   to __VARS_WEBERA in the correct format, using the provided arguments.
#
#   Function called by ().
#
# Arguments:
#  $1 - varOrigin [vdef|args|file|strn]
#  $2 - varPath (for files)
#  $3 - configuration
# Called by:
#   readConfig()
#
__varsPush() {
	declare varOrigin="$1" varPath="$2" configuration="$3"
	declare configLine

	local IFSbkp="$IFS"; IFS=$'\n'
	for configLine in $(printf '%s' "$configuration" \
		| grep '^config' \
		| cut -d ':' -f2- \
		| sed "s/$_WS*:$_WS*/=/" \
		| sed "$_SED_TRIM_WS" \
		); do
		if [[ "$configLine" != _* ]]; then # only read public variables
			printf -v __VARS_WEBERA '%s' \
			"$__VARS_WEBERA"$'\n'"[$varOrigin]:$varPath:$configLine"
		fi
	done
	IFS="$IFSbkp"
} # __varsPush()


#-------------------------------------------------------------------------------
#   __timeReport
#
#   Prints the spent time on the script, in milliseconds.
#
# Arguments:
#  $1 - if true, prints the time beautified
#
__timeElapsed() {
	local beautiful="$1"
	local -i timeStampFinal="$(date '+%s%3N')" || true
	local -i timeElapsed="$((timeStampFinal-__WEBERA_TIME_STAMP))"
	if [[ "$beautiful" == true ]]; then
		printf "$(__timeBeautify "$timeElapsed")"
	else
		printf "$timeElapsed"
	fi
}


#-------------------------------------------------------------------------------
#   __timeBeautify
#
#   Formats a ms time into a string showing days, hours, minutes and or seconds
#
# Arguments:
#  $1 - time in milliseconds
#
__timeBeautify() {
	local -i ms="$1"
	declare timeStr timeOn

	local -i s="$((ms/1000%60))"
	local -i m="$((ms/60000%60))"
	local -i h="$((ms/3600000%24))"
	local -i d="$((ms/86400000))"
	[[ "$d" -gt 0 ]] && timeStr+="${d}d " && timeOn=true
	[[ "$h" -gt 0 || -n "$timeOn" ]] && timeStr+="${h}h " && timeOn=true
	[[ "$m" -gt 0 || -n "$timeOn" ]] && timeStr+="${m}m " && timeOn=true
	[[ -n "$timeOn" ]] && timeStr+="${s}s " # shows seconds if time > 1m
	[[ "$m" -lt 1 && -z "$timeOn" ]] && timeStr+="${ms}ms "
	printf '%s' "${timeStr}"
}

[[ "$0" == "$BASH_SOURCE" ]] && main "$@" # Run if not sourced
