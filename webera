#!/usr/bin/env bash
#
# webera
#
# is a simple, handy & versatile shellscript for static website generation
#
# Repository: https://github.com/andamira/webera
# Version: 0.1.23
#
# Author: Jos√© Luis Cruz (andamira)
# License: MIT
#
## Dependencies:
#     bash 4 , grep (with PCRE support) , sed , awk
#
## Optional Dependencies:
#     python | php (to leverage their built-in web server)
#
# Originally Inspired by Statix
#     https://gist.github.com/plugnburn/c2f7cc3807e8934b179e
##

main() {

	## CONFIGURABLE OPTIONS

	# Paths
	local DIR_TEMPLATES=tem
	local DIR_RESOURCES=res
	local DIR_BUILD=build
	local DIR_OUTPUT=out
	local FILE_CONFIG=.weberarc

	# Web Browser
	local WEB_BROWSER_BIN="firefox" # | chromium-browser | google-chrome | vivaldi | ...
	local SERVER_TYPE="python"
	local -i SERVER_PORT=8192

	# Log
	local FILE_LOG=log.txt
	local OPTION_CLEAR_LOG=false
	local -i OPTION_LOG_LEVEL=0 # 0 = no log | 1 | 2 | 3

	# Delete output & build directories
	local OPTION_DELETE_DIR_OUTPUT=true
	local OPTION_DELETE_DIR_BUILD=true


	## INTERNALS

	local OPERATIONAL=false

	local OPTION_PROCESS_TEMPLATES=false
	local OPTION_PROCESS_RESOURCES=false
	local OPTION_LOAD_IN_WEB_BROWSER=false

	local FILE_CONFIG_GENERATE=false # has it been requested to generate? (-n)
	local FILE_CONFIG_EXPLICIT=false # has it been explicitly indicated?  (-C)

	declare -A ARG_OPTIONS
	declare -A DEFINED_CMD_MAP

	local -i NESTING_LEVEL=0
	local -ri NESTING_MAX=8

	local -r DATE=$(date '+%Y-%m-%d %H:%M:%S')
	local PRELOG="" # where saving the log before the logfile is ready
	local -i LOG_LEVEL_MIN=1
	local -i LOG_LEVEL_MAX=3

	# reusable regexp patterns
	local -r WS="[[:space:]]" # whitespace
	local -r SED_TRIM_WHITESPACE="s/^$WS*//;s/$WS*$//"
	local -r SED_DEL_COMMENTS="/^$WS*#.*/d"
	local -r SED_DEL_EMPTYLINES="/^$WS*$/d"
	local -r SED_JOIN_SPLITLINES=':x; /\\$/ { N; s/\\\n//; tx }' # ending in \


	## MAIN PROCESS

	setupLog start

	parseArguments "$@"

	readConfig "/etc/weberarc"
	readConfig "$HOME/.weberarc"
	readConfig "$FILE_CONFIG"

	configureSettings

	# Override the settings with the parsed arguments
	for OPT in "${!ARG_OPTIONS[@]}"; do
		printf -v ${OPT} "${ARG_OPTIONS[$OPT]}"
	done

	if [[ "$OPERATIONAL" == false ]]; then
		printf "You must use at least one MAIN FLAG!\n\n"
		usage
	fi

	setupLog noprelog

	deleteDirectories

	defineCommands

	if [[ $OPTION_PROCESS_RESOURCES == true ]]; then
		processResources
	fi

	if [[ $OPTION_PROCESS_TEMPLATES == true ]]; then
		processTemplates
	fi

	printf "Done.\n"

	if [[ $OPTION_LOAD_IN_WEB_BROWSER == true ]]; then
		serverSetup
		previewWebsite
	fi
}

usage() {
	cat <<ENDHERE
Usage: ./webera -[trwn] [optional flags]

MAIN FLAGS

  -t              process the templates
  -r              process the resources
  -w              preview in web browser

  -n              generate a new configuration file

OPTIONAL FLAGS                      (default value)

  -C <FILE>       indicate the configuration file ($FILE_CONFIG)

  -T <DIR>        indicate the templates directory ($DIR_TEMPLATES)
  -R <DIR>        indicate the resources directory ($DIR_RESOURCES)
  -O <DIR>        indicate the output directory ($DIR_OUTPUT)
  -B <DIR>        indicate the build directory ($DIR_BUILD)

  -d              switch deleting the output dir (delete=$OPTION_DELETE_DIR_OUTPUT)
  -c              switch clearing the log file (clear=$OPTION_CLEAR_LOG)

  -L <NUMBER>     log level [0=none|1|2|3] ($OPTION_LOG_LEVEL)
  -G <FILE>       log file ($FILE_LOG)
  -W <BIN>        web browser binary ($WEB_BROWSER_BIN)

FILE CONFIG
  You can set all these options, and more, in $FILE_CONFIG)
ENDHERE
	exit 1
}

parseArguments() {
# $@ = all the arguments

	local OPTIND OPTION

	while getopts ':trwnC:T:R:O:B:dcL:G:W:h:' OPTION; do
		case "$OPTION" in
			t) OPERATIONAL=true; OPTION_PROCESS_TEMPLATES=true ;;
			r) OPERATIONAL=true; OPTION_PROCESS_RESOURCES=true ;;
			w) OPERATIONAL=true; OPTION_LOAD_IN_WEB_BROWSER=true ;;

			n) OPERATIONAL=true; FILE_CONFIG_GENERATE=true ;;

			C) FILE_CONFIG="$OPTARG"
				FILE_CONFIG_EXPLICIT=true;
				;;

			# The following options can also be defined in $FILE_CONFIG, but
			# passing them as arguments to the script has a higher priority.

			T) ARG_OPTIONS[DIR_TEMPLATES]="$OPTARG" ;;
			R) ARG_OPTIONS[DIR_RESOURCES]="$OPTARG" ;;
			O) ARG_OPTIONS[DIR_OUTPUT]="$OPTARG" ;;
			B) ARG_OPTIONS[DIR_BUILD]="$OPTARG" ;;

			# These flags switches the default boolean value,
			# (without checking first the values in file config).
			d) if [ "$OPTION_DELETE_DIR_OUTPUT" == true ]; then
					ARG_OPTIONS[OPTION_DELETE_DIR_OUTPUT]=false
				else
					ARG_OPTIONS[OPTION_DELETE_DIR_OUTPUT]=true
				fi
				;;
			c) if [ "$OPTION_CLEAR_LOG" == true ]; then
					ARG_OPTIONS[OPTION_CLEAR_LOG]=false
				else
					ARG_OPTIONS[OPTION_CLEAR_LOG]=true
				fi
				;;

			L) ARG_OPTIONS[OPTION_LOG_LEVEL]="$OPTARG" ;;
			G) ARG_OPTIONS[FILE_LOG]="$OPTARG" ;;

			W) ARG_OPTIONS[WEB_BROWSER_BIN]="$OPTARG" ;;

			h|*) usage ;;
		esac
	done
	shift $((OPTIND-1))
}

setupLog() {
	declare mode="$1" # [start|noprelog]

	if [ "$mode" == "start" ]; then
		log "\n===============[$DATE]==============@\n" 1

	else
		if [[ $OPTION_CLEAR_LOG == true ]]; then
			log "\nWarning: deleting previous log file '$FILE_LOG'" 3 warn
			rm $FILE_LOG 2>/dev/null;
		fi

		# Write the pre-saved log to the file
		#
		# 1. filter out the lines with log level greater than current
		# 2. leave only the log message, discard the rest. (TODO: filter out error|warn)
		# 3. bring back the newlines
		# 4. put the log level in the date header
		local PARSED_PRELOG=$(printf "$PRELOG" \
			| awk -v ll=$OPTION_LOG_LEVEL -F '|' '$1<=ll' \
			| cut -d'|' -f3- \
			| tr '\a' '\n' \
			| sed "s/====@$/====$OPTION_LOG_LEVEL/" )

		PRELOG="noprelog"

		if [ "$PARSED_PRELOG" != "" ]; then
			log "$PARSED_PRELOG";
		fi
	fi
}

log() {
	declare logMsg=$1 logLevelNeeded=$2 logType=$3

	if [ "$PRELOG" == "noprelog" ]; then

		if [[ -z "$logLevelNeeded" || ( "$logLevelNeeded" -lt "1" ) ]]; then
			LOG_LEVEL=$LOG_LEVEL_MIN
		else
			if [[ "$LOG_LEVEL" -gt "$LOG_LEVEL_MAX" ]]; then
				LOG_LEVEL=$LOG_LEVEL_MAX
			else
				LOG_LEVEL=$logLevelNeeded
			fi
		fi

		if [ $LOG_LEVEL -le $OPTION_LOG_LEVEL ]; then
			printf "$logMsg\n" >> $FILE_LOG
		fi
	else
		# Pre-save this log message as a single line
		#
		# 1. replace the newlines with a BEL
		# 2. put the log level and type at the beginning
		local msg_1line=$(printf "$logMsg" | tr '\n' '\a')
		PRELOG="$PRELOG\n$logLevelNeeded|$logType|$msg_1line"
	fi
}

serverSetup() {
	case $SERVER_TYPE in
		python)
			START_SERVER="pushd $DIR_OUTPUT; python -m SimpleHTTPServer $SERVER_PORT"
			STOP_SERVER="kill \$(pgrep -f \"python -m SimpleHTTPServer\")"
			;;
		php)
			START_SERVER="php -S localhost:$SERVER_PORT -t $DIR_OUTPUT"
			STOP_SERVER="kill \$(pgrep -f \"php -S localhost\")"
			;;
		none)
			START_SERVER=""
			STOP_SERVER=""
			;;
		*)
			log "Not recognized SERVER_TYPE='$SERVER_TYPE'" 2 warn
			START_SERVER=""
			STOP_SERVER=""
			;;
	esac
}

previewWebsite() {
	printf "Loading website in '$WEB_BROWSER_BIN'..."

	if [ ! -z "$START_SERVER" ]; then
		printf " (Use CTRL+C to stop the web server)\n"
	else
		echo
	fi

	local RUN_BROWSER="$WEB_BROWSER_BIN http://localhost:$SERVER_PORT &"

	case $OPTION_LOG_LEVEL in
		0)
			# no CLI output whatsoever
			local REDIR_CLI_OUTPUT="> /dev/null 2>&1"
			;;
		1)
			# hide errors
			local REDIR_CLI_OUTPUT="2>/dev/null"
			;;
		*)
			# output everything
			local REDIR_CLI_OUTPUT=""
			;;
	esac

	sleep 1s && eval $RUN_BROWSER > /dev/null 2>&1

	if [ ! -z "$START_SERVER" ]; then
		eval "$STOP_SERVER $REDIR_CLI_OUTPUT"; eval "$START_SERVER $REDIR_CLI_OUTPUT"
	fi
}

deleteDirectories() {
	if [[ $OPTION_DELETE_DIR_BUILD ]]; then
		rm -r "$DIR_BUILD" 2>/dev/null
	fi

	if [[ $OPTION_DELETE_DIR_OUTPUT && ( \
			$OPTION_PROCESS_RESOURCES == true \
			|| $OPTION_PROCESS_TEMPLATES == true \
		) ]]; then

		rm -r "$DIR_OUTPUT" 2>/dev/null
	fi
}

readConfig() {
	local FILE="$1" # string

	if [ -f "$FILE" ]; then # config file exists
		# and tried to generate a new config file
		if [[ "$FILE_CONFIG_GENERATE" == true ]] \
			&& [[ "$FILE" == "$FILE_CONFIG" ]]; then
			log "Warning: local config file '$FILE' already exists. Overwrite is not allowed.\n" 2 warn
		fi

		local TMPCONF="$(cat "$FILE" \
			| sed -e "$SED_TRIM_WHITESPACE" \
			| sed -e "$SED_DEL_COMMENTS" -e "$SED_DEL_EMPTYLINES" \
			| sed -e "$SED_JOIN_SPLITLINES" \
		)"$'\n'
		CONFIG="$CONFIG$TMPCONF" # append to previously read configuration

	else # the config file doesn't exist

		# it is the local config file
		if [ "$FILE" == "$FILE_CONFIG" ]; then

			if [[ "$FILE_CONFIG_GENERATE" == true ]]; then # generate a new one
				generateConfig
			else
				if [[ $FILE_CONFIG_EXPLICIT == true ]]; then # it was explicitly indicated
					printf "ERROR: Configuration file '%s' doesn't exist.\n" "$FILE_CONFIG"
					exit 2
				else
					log "\nWarning: project's config file '$FILE_CONFIG' doesn't exist." 3 warn
				fi
			fi
		else
			log "\nWarning: can't find global config file '$FILE'" 3 warn
		fi
	fi
}

configureSettings() {
	# Parse the commands for processing resources
	local SETTINGS="$(echo "$CONFIG" | grep ^$WS*config$WS*: )"

	if [ "$SETTINGS" ]; then
		log "\nConfiguring settings...\n------------------------------------------------------" 1

		local OLDIFS="$IFS"; IFS=$'\n'
		for S in $SETTINGS; do

			local setting_name=$(echo "$S" | cut -d':' -f2 | sed -e "$SED_TRIM_WHITESPACE")
			local setting_value=$(echo "$S" | cut -d':' -f3 | sed -e "$SED_TRIM_WHITESPACE")
			local setting_previous_value=${!setting_name}

			log "  setting: $setting_name=$setting_value (previous=$setting_previous_value)" 1

			# NOTE: There're currently no checks. Any global variable can be (re)assigned.
			printf -v $setting_name "$setting_value"
		done
	fi
}

generateConfig() {
	local configLines=()

	if [ "$FILE_CONFIG_EXPLICIT" == true ]; then
		configLines+=("config : FILE_CONFIG : $FILE_CONFIG")
	fi

	for OPT in "${!ARG_OPTIONS[@]}"; do
		configLines+=("config : $OPT : ${ARG_OPTIONS[$OPT]}")
	done

	for LINE in "${configLines[@]}"; do
		printf '%s\n' "$LINE" >> "$FILE_CONFIG"
	done
}

defineCommands() {
	local DEFINED_CMD="$(echo "$CONFIG" | grep ^$WS*define_cmd$WS*: )"

	if [ "$DEFINED_CMD" ]; then
		local CNUM=$(echo "$DEFINED_CMD" | wc -l )
		log "\nDefining $CNUM commands...\n------------------------------------------------------" 1
	fi

	local OLDIFS="$IFS"; IFS=$'\n'
	for C in $DEFINED_CMD; do

		local cmd_name=$(echo "$C" | cut -d':' -f2 | sed -e "$SED_TRIM_WHITESPACE" )
		local cmd_action=$(echo "$C" | cut -d':' -f3- | sed -e "$SED_TRIM_WHITESPACE" )

		DEFINED_CMD_MAP[$cmd_name]=$cmd_action

		log "  $cmd_name='$cmd_action'" 2
	done
	IFS="$OLDIFS"
}

processResources() {
	log "\nProcessing resources...\n------------------------------------------------------" 1

	if [ -d "$DIR_RESOURCES" ]; then

		local RESOURCE_CMD_LIST="$(echo "$CONFIG" | grep ^$WS*resource$WS*: )"

		if [ "$RESOURCE_CMD_LIST" ]; then
			local RNUM=$(echo "$RESOURCE_CMD_LIST" | wc -l )
			log "Found $RNUM operations on resources:" 1
		fi

		local OLDIFS="$IFS"; IFS=$'\n'
		for RCMD in $RESOURCE_CMD_LIST; do

			local operation=$(echo "$RCMD" | cut -d':' -f2 | sed -e "$SED_TRIM_WHITESPACE" )
			local fileOrigin=$(echo "$RCMD" | cut -d':' -f3 | sed -e "$SED_TRIM_WHITESPACE" )
			local fileTarget=$(echo "$RCMD" | cut -d':' -f4 | sed -e "$SED_TRIM_WHITESPACE" )

			log "  $operation: $fileOrigin > $fileTarget" 1

			if [ ! -e "$DIR_RESOURCES/$fileOrigin" ]; then
				log "  ERROR: '$fileOrigin' don't exist" 1 error
				continue # XXX do break instead?
			fi

			# built-in command for resources?
			case "$operation" in
				"copy")
					mkdir -p $DIR_OUTPUT/$DIR_RESOURCES/$(dirname $fileTarget)
					cp -r "$DIR_RESOURCES/$fileOrigin" \
						"$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget"
					;;
				*)
					# custom command? Paths are adapted for resources
					if [ "${DEFINED_CMD_MAP[$operation]}" ]; then

						local CMD=$(echo ${DEFINED_CMD_MAP[$operation]} \
							| sed "s|{ORIGIN}|$DIR_RESOURCES/$fileOrigin|g" \
							| sed "s|{BUILD}|$DIR_BUILD/$fileOrigin|g" \
							| sed "s|{TARGET}|$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget|g" \
						)

						# Create target paths
						if [[ "${DEFINED_CMD_MAP[$operation]}" =~ "{BUILD}" ]]; then
							mkdir -p $(dirname "$DIR_BUILD/$fileTarget")
						fi
						if [[ "${DEFINED_CMD_MAP[$operation]}" =~ "{TARGET}" ]]; then
							mkdir -p $(dirname "$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget")
						fi

						log "  Executing: $CMD" 3
						eval $CMD # HACK dangerous
					else
						log "  ERROR: operation '$operation' not recognized" 1 error
					fi
					;;
			esac
		done
		IFS="$OLDIFS"
	else
		echo "No resources dir '$DIR_RESOURCES' found."
	fi
}

processTemplates() {
	log "\nProcessing templates...\n------------------------------------------------------" 1

	if [ -d "$DIR_TEMPLATES" ]; then

		local TEMPLATE_CMD_LIST="$(echo "$CONFIG" | grep ^$WS*template$WS*: )"

		if [ "$TEMPLATE_CMD_LIST" ]; then
			local TNUM=$(echo "$TEMPLATE_CMD_LIST" | wc -l )
			log "Found $TNUM operations on templates:" 1
		fi

		local OLDIFS="$IFS"; IFS=$'\n'
		for TCMD in $TEMPLATE_CMD_LIST; do

			local operation=$(echo "$TCMD" | cut -d':' -f2 | sed -e "$SED_TRIM_WHITESPACE" )
			local fileOrigin=$(echo "$TCMD" | cut -d':' -f3 | sed -e "$SED_TRIM_WHITESPACE" )
			local fileTarget=$(echo "$TCMD" | cut -d':' -f4 | sed -e "$SED_TRIM_WHITESPACE" )

			log "  $operation: $fileOrigin > $fileTarget" 1

			# built-in command for templates?
			case "$operation" in
				"route")
					local urlPath=$fileTarget

					if [[ "$fileOrigin" && "$urlPath" ]]; then

						mkdir -p "${DIR_OUTPUT}${urlPath}"
						templateRender "$fileOrigin" > "${DIR_OUTPUT}${urlPath}/index.html"
					else
						log "  ERROR: missing arguments for 'template:route' command" 1 error
					fi
					;;

				*)
					# custom command? Paths are adapted for templates
					if [ "${DEFINED_CMD_MAP[$operation]}" ]; then

						local CMD=$(echo ${DEFINED_CMD_MAP[$operation]} \
							| sed "s|{ORIGIN}|$DIR_TEMPLATES/$fileOrigin|g" \
							| sed "s|{BUILD}|$DIR_BUILD/$fileOrigin|g" \
							| sed "s|{TARGET}|$DIR_OUTPUT/$fileTarget|g" \
						)

						# Create target paths
						if [[ "${DEFINED_CMD_MAP[$operation]}" =~ "{BUILD}" ]]; then
							mkdir -p $(dirname "$DIR_BUILD/$fileTarget")
						fi
						if [[ "${DEFINED_CMD_MAP[$operation]}" =~ "{TARGET}" ]]; then
							mkdir -p $(dirname "$DIR_OUTPUT/$DIR_RESOURCES/$fileTarget")
						fi

						log "  Executing: $CMD" 3
						eval $CMD # HACK dangerous
					else
						log "  ERROR: operation '$operation' not recognized" 1 error
					fi
					;;
			esac
		done
		IFS="$OLDIFS"
	else
		echo "No templates dir '$DIR_TEMPLATES' found."
	fi
}

templateParseIncludes() {
	declare templateFileName=$1

	((NESTING_LEVEL++))
	if [ $NESTING_LEVEL -gt $NESTING_MAX ]; then
		log "  ERROR: max nesting level ($NESTING_MAX) reached for template $templateFileName" 1 error
		exit 3
	fi

	# Parse template
	# TODO: search first in DIR_BUILD, if not found, don't ouput anything
	local templateFile="${DIR_TEMPLATES}/$templateFileName"
	if [ -f "$templateFile" ]; then
		local templateContent="$(<$templateFile)"
	else
		log "  ERROR: No template found '$templateFile'" 1 error
		return
	fi
	local directives_include=$(grep -Po "<!--$WS*%include$WS*:.*?-->" "$templateFile")
	local D=''

	local OLDIFS="$IFS"; IFS=$'\n'

	# Remove duplicates
	if [ "$directives_include" ]; then
		directives_include=$(echo "$directives_include" | uniq)
	fi

	for D in $directives_include; do
		local includedFileName=$(printf '%s' "$D" | sed -n -e "s/<\!--$WS*%include$WS*:$WS*\(.*\)$WS*-->/\1/p" | sed -e "s/$WS*$//" )
		log "    include: '$includedFileName'" 2

		# Parse included template for further includes
		local includedFileContent="$(templateParseIncludes ${includedFileName})"

		# Mass-replace directive with template contents
		templateContent="${templateContent//$D/$includedFileContent}"
	done
	IFS="$OLDIFS"

	((NESTING_LEVEL--))

	printf '%s' "$templateContent"
}

templateRender() {
	declare templateFileName=$1

	local templateText="$(templateParseIncludes $templateFileName)"

	# Template tags must be one-liners
	local directives_set=$(printf '%s' "$templateText" | grep -Po "<!--$WS*%set$WS*:.*?-->")
	local directives_cmd=$(printf '%s' "$templateText" | grep -Po "<!--$WS*%cmd$WS*:.*?-->")
	local directives_setcmd=$(printf '%s' "$templateText" | grep -Po "<!--$WS*%setcmd$WS*:.*?-->")
	local D=''

	# text comments
	#
	# <!--// Comment -->
	#
	templateText=$(echo "$templateText" | sed -e :a -re "s/<!--$WS*\/\/.*?-->//g;/<!--\/\//N;//ba")

	local OLDIFS="$IFS"; IFS=$'\n'

	# set variables
	#
	# <!--%set:VARIABLE=something-->
	# <!--@VARIABLE-->
	#
	for D in $directives_set; do
		local SET=$(printf '%s' "$D" | sed -n -e "s/<\!--$WS*%set$WS*:$WS*\(.*\)$WS*-->/\1/p" | sed -e "s/$WS*$//")
		local SETVAR="${SET%%=*}"
		local SETVAL="${SET#*=}"
		log "      set: $SETVAR = $SETVAL" 3

		# Cross-platform syntax to replace including newlines
		# http://stackoverflow.com/a/1252191
		templateText=$(echo "$templateText" \
			| sed -e ":a" -e "N" -e "\$!ba" -e "s/$D\n\?//g")
		templateText=$(echo "$templateText" \
			| sed -e ":a" -e "N" -e "\$!ba" -e "s/<!--$WS*@$SETVAR$WS*-->\n\?/$SETVAL/g")
	done

	# execute commands, render output
	#
	# <!--%cmd: ls -l -->
	#
	for D in $directives_cmd ; do
		local CMD=$(printf '%s' "$D" | sed -n -e "s/^.*<\!--$WS*%cmd$WS*:$WS*\(.*\)$WS*-->.*$/\1/p" | sed -e "s/$WS*$//")
		local CMDOUT=$(eval "$CMD")
		log "    cmd: $CMD" 3

		local -i CMDOUT_MAX=50
		local -i CMDOUT_LEN=$(printf "%s" "$CMDOUT" | wc -c)

		if [ "$CMDOUT_LEN" -le $CMDOUT_MAX ]; then
			log "      =: $CMDOUT" 3
		else
			log "      =: $(echo $CMDOUT | tr '\n' ' ' \
				| head -c$CMDOUT_MAX) (...) + $(($CMDOUT_LEN-$CMDOUT_MAX)) chars" 3
		fi

		# attribution: @anubhava in http://stackoverflow.com/a/40749641/940200
		templateText=$(awk -v repl="$CMDOUT" 'FNR==NR {
				a = a $0; next
			}
			n = index($0, a) {
				$0 = substr($0, 1, n-1) repl substr($0, n+length(a))
			} 1' <(printf '%s\n' "$D") <(printf '%s' "$templateText")
		)
	done

	# set variables to commands output
	#
	# <!--%setcmd:VARIABLE=ls -l-->
	# <!--@VARIABLE-->
	#
	for D in $directives_setcmd; do
		local SETCMD=$(printf "$D" | sed -n -e "s/^.*<\!--$WS*%setcmd$WS*:$WS*\(.*\)$WS*-->.*$/\1/p" | sed -e "s/$WS*$//")
		local SETCMDVAR="${SETCMD%%=*}"
		local SETCMDVAL="${SETCMD#*=}"
		local SETCMDOUT=$(eval $SETCMDVAL)
		log "    setcmd: $SETCMDVAR = $SETCMDVAL" 3

		templateText=$(echo "$templateText" \
			| sed -e ":a" -e "N" -e "\$!ba" -e "s/$D\n\?//g")
		templateText=$(echo "$templateText" \
			| sed -e ":a" -e "N" -e "\$!ba" -e "s/<!--$WS*@$SETCMDVAR$WS*-->\n\?/$SETCMDOUT/g")
	done

	IFS="$OLDIFS"

	log "" 2

	printf "%s" "$templateText"
}

main "$@"
